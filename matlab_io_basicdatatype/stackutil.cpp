/*
 *  stackutil.cpp
 *  
 *
 *  Created (extracted from earlier codes) by Hanchuan Peng on 7/31/06.
 *  Modified on 060803 by Hanchuan Peng: change the size information to be 4 long (4-byte) instead of 4-short-int (2byte).
 *  Updated 060806: correct a bug in 4-byte swapping. And notice the compatibility of 32-bit system and 64-bit system about the length of int/long types
 *  Copyright 2006 __Hanchuan Peng__. All rights reserved.
 *
 *  060816: add tif support
 *  060828: add surfix extraction function here
 *
 *  060920: add 2-byte formatted raw format support back to increase the compatibility of existing data in the worm project
 *
 *  070214: add two simple interface to read any file formats supported (raw or tif) based on the surfix of filename
 *  070220: add b_VERBOSE_PRINT
 *  070306: add tif file exist verification
 * 070713: George tried to add lsm file reading functions but unsucecssful
 * 070806: Hanchuan added lsm 8-bit reading functions
 * 070807/08: try to handle the imcomplete data generated by the Zeiss lsm writer. The current solution is to change the a function in libtiff tif_lzw.c file 
 *            and force it return the value 2, instead of 0, when the input strip size is bigger than real. In this way, the tif function TIFFReadEncodedStrip()
 *            will continue to do postprocessing of the already read data.
 *
 *            Special note: in this way, I will have to build a customary libtiff library and install at my own location ~/work/3rdsoft/lib instead of 
 *                          the default /usr/local/lib. When I will have to reset the .bashrc/.profile file and use LD_LIBRARY_PATH (and probably also DYLD_LIBRARY_PATH)
 *                          for Mac to link them. This works for the case of V3D already. However, interestingly, I read an article arguing that using otool/ldd/nm, the dependency
 *                          of objects files can be seen, and that Mac uses the absolute path in library dependency, and that LD_LIBRARY_PATH does not work. The 
 *                          interesting thing is that after I tried both, I found otool does show the absolute path, but LD_LIBARY_PATH/DYLD_LIBRARY_PATH works!
 *
 * 070819: add several functions to read LSM file thumbnails and middle slice.
 * 071125: update the copy on my G4 Mac so that it use CPP interface to Gene's codes instead of the C interface
 * 080103: add some further verbose printing
 * 20080213: add interface functions to read single slice of a tiff stack, or the respective thumbnail: Note that the lsm and tif interfaces are DIfferent!
 * 20080301: add handling of 12/16 bit LSM
 * 20080302: change the include "basic_memory.h" to .cpp, due to the template instantiation in V3D
 * 20080401: add the ifndef tag as this will often be included in other files
 * 20080828: add file size limitation, so avoid loading too big file that may cause the tif reader to crash
 * 20080930: return the original tiff pixel value but not the automatically scaled down version
 */

#define _FILE_OFFSET_BITS  64  //20140919

#ifndef __STACKUTIL_CPP__
#define __STACKUTIL_CPP__

//#include "../elementmexheader.h"

#include "stackutil.h"
#include "basic_memory.cpp" //change basic_memory.h to basic_memory.cpp, 080302

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
/*
extern "C" {
*/
#include "mg_image_lib.h" 
/*
};
*/

#define b_VERBOSE_PRINT 1

//int b_VERBOSE_PRINT=1;
/* a simple surfix function.*/

char * getSuffix(char *filename)
{
	if (!filename)
		return 0;
	
	long i=0,k=-1;
	while (filename[i]!='\0')
	{
		if (filename[i]=='.')
			k=i;
		i++;
	}
	
	if (k==-1 || k==i)
		return 0;
	
	return (filename+k+1);
}


/* The following is the core function for image stack reading of 2 byte raw*/

int loadRaw2Stack_2byte(char * filename, unsigned char * & img, long * & sz, int & datatype)
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	
	int berror = 0;
	
	FILE * fid = fopen(filename, "rb");
	if (!fid) 
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	
	fseek (fid, 0, SEEK_END);
	long fileSize = ftell(fid);
	rewind(fid);
	
	/* Read header */
	
	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey); 
	
	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}
	
	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	long nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';
	
	long i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	
	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	
	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	
	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
    
	
	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);
	
	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}
	
	long unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	
	short int mysz[4];
	fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}
	
	if (sz) {delete []sz; sz=0;}
	sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)  
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	
	long totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (long)mysz[i];
		totalUnit *= sz[i];
	}
	
	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img) 
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}
	
	/* swap the data bytes if necessary */
	
	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}
	
	
	/* clean and return */
	
	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412
	
	return berror;
}


/* The following is the core function for image stack writing of 2-byte raw*/

int saveStack2Raw_2byte(const char * filename, const unsigned char * img, const long * sz, int datatype)
{
	/* This function save a data stack to raw file */
	
	int berror = 0;
	long i;
	
	FILE * fid = fopen(filename, "wb");
	if (!fid) 
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}
	
	/* Write header */
	
	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey); 
	
	long nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}
	
	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}
	
	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}
	
	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.
	
	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}
	
	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)  
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}
	
	long unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	
	short int mysz[4];
	//if (b_swap)  { 
	for (i=0;i<4;i++) mysz[i] = (short int) sz[i];
	//swap2bytes((void *)(mysz+i));
	//}
	nwrite = fwrite(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
if (nwrite!=4)  
{
    printf("Writing file error.\n");
    berror = 1;
    return berror;
}

long totalUnit = 1;
for (i=0;i<4;i++)
{
    totalUnit *= sz[i];
}

nwrite = fwrite(img, unitSize, totalUnit, fid);
if (nwrite!=totalUnit)
{
    printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
    berror = 1;
    return berror;
}

/* swap the data bytes if necessary */
/*
 if (b_swap==1)
 {
	 if (unitSize==2)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap2bytes((void *)(img+i*unitSize));
		 }
	 }
	 else if (unitSize==4)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap4bytes((void *)(img+i*unitSize));
		 }
	 }
 }
 */


/* clean and return */

fclose(fid); 

return berror;
}

/* The following is the core function for image stack reading */

int loadRaw2Stack(char * filename, unsigned char * & img, long * & sz, int & datatype) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [long long]=[%ld], [long]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", 
		//mexPrintf("size of [long long]=[%d], [long]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n", 
          sizeof(long long), sizeof(long), sizeof(int), sizeof(short int), sizeof(double), sizeof(float)); 
    //printf("\n\n\n");
    
	int berror = 0;
	
	FILE * fid = fopen(filename, "rb");
	if (!fid) 
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	
	fseek (fid, 0, SEEK_END);
	long fileSize = ftell(fid);
	rewind(fid);
	
	/* Read header */
	
	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey); 
	
	if (fileSize<lenkey+2+4*4+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}
	
	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	long nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';
	
	long i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}
	
	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	
	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}
	
	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }
    
	
	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);
	
	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}
	
	long unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	
	//short int mysz[4];
	//long mysz[4];//060803
	BIT32_UNIT mysz[4];//060806
		mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
		int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
		if (tmpn!=4)
		{
			printf("This program only reads [%d] units.\n", tmpn);
			berror=1;
			return berror;
		}
		if (b_swap)
		{
			for (i=0;i<4;i++)
			{
				//swap2bytes((void *)(mysz+i));
				if (b_VERBOSE_PRINT)
					printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]); 
				swap4bytes((void *)(mysz+i));
				if (b_VERBOSE_PRINT)
					printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
			}
		}
		
		if (sz) {delete []sz; sz=0;}
		sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
		if (!sz)  
		{
			printf("Fail to allocate memory.\n");
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
		}
		
		long totalUnit = 1;
		for (i=0;i<4;i++)
		{
			sz[i] = (long)mysz[i];
			totalUnit *= sz[i];
		}
		
			//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
			//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
		{
			printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
			printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
			if (b_VERBOSE_PRINT)
			{
				printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
			}
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			berror = 1;
			return berror;
		}
		
		if (img) {delete []img; img=0;}
		img = new unsigned char [totalUnit*unitSize];
		if (!img) 
		{
			printf("Fail to allocate memory.\n");
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			berror = 1;
			return berror;
		}
		
		nread = fread(img, unitSize, totalUnit, fid);
		if (nread!=totalUnit)
		{
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		/* swap the data bytes if necessary */
		
		if (b_swap==1)
		{
			if (unitSize==2)
			{
				for (i=0;i<totalUnit; i++)
				{
					swap2bytes((void *)(img+i*unitSize));
				}
			}
			else if (unitSize==4)
			{
				for (i=0;i<totalUnit; i++)
				{
					swap4bytes((void *)(img+i*unitSize));
				}
			}
		}
		
		
		/* clean and return */
		
		if (keyread) {delete [] keyread; keyread = 0;}
		fclose(fid); //bug fix on 060412
		
		return berror;
}


/* The following is the core function for image stack writing */

int saveStack2Raw(const char * filename, const unsigned char * img, const long * sz, int datatype)
{
	/* This function save a data stack to raw file */
	if (b_VERBOSE_PRINT)
		printf("size of [long long]=[%ld], [long]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", sizeof(long long), sizeof(long), sizeof(int), sizeof(short int), sizeof(double), sizeof(float)); 
	
	int berror = 0;
	long i;
	
	FILE * fid = fopen(filename, "wb");
	if (!fid) 
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}
	
	/* Write header */
	
	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey); 
	
	long nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}
	
	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}
	
	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}
	
	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.
	
	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}
	
	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)  
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}
	
	long unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
	
	//short int mysz[4];
	BIT32_UNIT mysz[4];//060806
					   //if (b_swap)  { 
					   //for (i=0;i<4;i++) mysz[i] = (short int) sz[i];
		for (i=0;i<4;i++) mysz[i] = (BIT32_UNIT) sz[i];
		//swap2bytes((void *)(mysz+i));
		//}
		nwrite = fwrite(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
if (nwrite!=4)  
{
    printf("Writing file error.\n");
    berror = 1;
    return berror;
}

long totalUnit = 1;
for (i=0;i<4;i++)
{
    totalUnit *= sz[i];
}

nwrite = fwrite(img, unitSize, totalUnit, fid);
if (nwrite!=totalUnit)
{
    printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
    berror = 1;
    return berror;
}

/* swap the data bytes if necessary */
/*
 if (b_swap==1)
 {
	 if (unitSize==2)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap2bytes((void *)(img+i*unitSize));
		 }
	 }
	 else if (unitSize==4)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap4bytes((void *)(img+i*unitSize));
		 }
	 }
 }
 */


/* clean and return */

fclose(fid); 

return berror;
}


/* check the machine endianness */

char checkMachineEndian()
{
    char e='N'; //for unknown endianness
    
    long int a=0x44332211;
    unsigned char * p = (unsigned char *)&a;
    if ((*p==0x11) && (*(p+1)==0x22) && (*(p+2)==0x33) && (*(p+3)==0x44))
        e = 'L';
    else if ((*p==0x44) && (*(p+1)==0x33) && (*(p+2)==0x22) && (*(p+3)==0x11))
        e = 'B';
    else if ((*p==0x22) && (*(p+1)==0x11) && (*(p+2)==0x44) && (*(p+3)==0x33))
        e = 'M';
    else
        e = 'N';
	
    printf("[%c] \n", e);
    return e;
}


void swap2bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+1);
    *(tp+1) = a;
}

void swap4bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+3);
    *(tp+3) = a;
    a = *(tp+1);
    *(tp+1) = *(tp+2);
    *(tp+2) = a;
}


int loadTif2Stack(char * filename, unsigned char * & img, long * & sz, int & datatype)
{
	int b_error=0;
	
	//070306: verify the file exists: Note that for some reasons, the printf() output does not show up in Matlab (mex file) but completely normal for other C executable (like laff). Strange.
	
	//fprintf(stderr, "Verify file existence.\n");
	FILE *tmp = fopen(filename, "r");
	if (!tmp) {fprintf(stderr, "The file [%s] does not exist.\n", filename); b_error=1; return b_error;}
	else {fclose(tmp);}
	
	
	//the following are the interface codes
	
	Stack *tmpstack = Read_Stack(filename);
	if (!tmpstack)
	{
		b_error=1;
		return b_error;    
	}
	
	//convert to hanchuan's format
	if (sz) {delete sz; sz=0;}
	if (img) {delete img; img=0;}
	
	sz=new long [4];
	if (sz)  
	{
		sz[0] = tmpstack->width;
		sz[1] = tmpstack->height;
		sz[2] = tmpstack->depth;
		switch (tmpstack->kind)
		{
			case GREY: 
				sz[3] = 1; 
				datatype = 1;
				break;
				
			case GREY16: 
				sz[3] = 1; 
				datatype = 2;
				break;
				
			case COLOR: 
				sz[3] = 3; 
				datatype = 1;
				break; 
				
			default: 
				printf("The type of tif file is not supported in this version.\n"); 
				if (sz) {delete sz; sz=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				break;
		}	
	}
	else
	{
		printf("Unable to allocate memory for the size varable! Return.\n");
		if (tmpstack)
		{
			Kill_Stack(tmpstack);
			tmpstack=0;
		}
		b_error=1;
		return b_error;
	}
	
	img = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]*datatype];
	if (!img)
	{
		printf("Unable to allocate memory for the image varable! Return.\n");
		if (tmpstack)	  {	Kill_Stack(tmpstack);	tmpstack=0;}
		if (sz) {delete sz; sz=0;}
		b_error=1;
		return b_error;
	}
	else
	{
		long i,j,k,c;
		long pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
		
		switch (tmpstack->kind)
		{
			case GREY: 
			case COLOR:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c);
				
				break;
				
			case GREY16: 
				{
					unsigned short int *img16 = (unsigned short int *)img;
					for (c=0;c<sz[3];c++)
						for (k=0;k<sz[2]; k++)
							for (j=0;j<sz[1]; j++)
								for (i=0;i<sz[0]; i++)
									//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
									//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
									img16[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c); //do not assume anything. 080930
				}
				
				break;
				
			default: 
				printf("The type of tif file is not supported in this version.\n"); 
				if (sz) {delete sz; sz=0;}
					if (img) {delete img; img=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				b_error=1; 
				return b_error;
				break;
		}	
	}
	
	
	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}
	
	return b_error;
	
}

int saveStack2Tif(const char * filename, const unsigned char * img, const long * sz, int datatype)
{
	int b_error=0;
	
	int i,j,k,c;
	for (i=0;i<4;i++)
	{
		if (sz[i]<0)
		{
			printf("The %d sz parameter is not valid [%ld]. Exit.\n", i, sz[i]);
			b_error=1;
			return b_error;
		}
	}
	
	if (!img)
	{
		printf("The input image pointer is null. Exit.\n");
		b_error=1;
		return b_error;
	}
	
	int kind;
	if (sz[3]==1)
		kind = GREY;
	else //if (sz[3]>1) //but only output the 3 first channels
		kind = COLOR;
	
	Stack *tmpstack = Make_Stack(kind, int(sz[0]), int(sz[1]), int(sz[2]));
	if (!tmpstack)
	{
		printf("Fail to allocate memory for tif output.\n");
		b_error=1;
		return b_error;
	}
	
	long pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	for (c=0;c<sz[3];c++)
		for (k=0;k<sz[2]; k++)
			for (j=0;j<sz[1]; j++)
				for (i=0;i<sz[0]; i++)
					Set_Stack_Pixel(tmpstack,i,j,k,c, img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i]);
	
	//output to file
	Write_Stack((char*)filename, tmpstack);
	
	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}
	
	return b_error;
}


int loadLsm2Stack_obsolete(char * filename, unsigned char * & img, long * & sz, int & datatype) //070713
{
	int b_error=0;
	
	//070306: verify the file exists: Note that for some reasons, the printf() output does not show up in Matlab (mex file) but completely normal for other C executable (like laff). Strange.
	
	//fprintf(stderr, "Verify file existence.\n");
	FILE *tmp = fopen(filename, "r");
	if (!tmp) {fprintf(stderr, "The file [%s] does not exist.\n", filename); b_error=1; return b_error;}
	else {fclose(tmp);}
	
	
	//the following are the interface codes
	
	Stack *tmpstack = Read_LSM_Stack(filename);
	if (!tmpstack)
	{
		b_error=1;
		return b_error;    
	}
	
	//convert to hanchuan's format
	if (sz) {delete sz; sz=0;}
	if (img) {delete img; img=0;}
	
	sz=new long [4];
	if (sz)  
	{
		sz[0] = tmpstack->width;
		sz[1] = tmpstack->height;
		sz[2] = tmpstack->depth;
		switch (tmpstack->kind)
		{
			case GREY: 
				sz[3] = 1; 
				datatype = 1;
				break;
				
			case GREY16: 
				sz[3] = 1; 
				datatype = 1;
				break;
				
			case COLOR: 
				sz[3] = 3; 
				datatype = 1;
				break; 
				
			default: 
				printf("The type of tif file is not supported in this version.\n"); 
				if (sz) {delete sz; sz=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				break;
		}	
	}
	else
	{
		printf("Unable to allocate memory for the size varable! Return.\n");
		if (tmpstack)
		{
			Kill_Stack(tmpstack);
			tmpstack=0;
		}
		b_error=1;
		return b_error;
	}
	
	img = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];
	if (!img)
	{
		printf("Unable to allocate memory for the image varable! Return.\n");
		if (tmpstack)	  {	Kill_Stack(tmpstack);	tmpstack=0;}
		if (sz) {delete sz; sz=0;}
		b_error=1;
		return b_error;
	}
	else
	{
		long i,j,k,c;
		long pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
		
		switch (tmpstack->kind)
		{
			case GREY: 
			case COLOR:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c);
				
				break;
				
			case GREY16: 
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
				break;
				
			default: 
				printf("The type of tif file is not supported in this version.\n"); 
				if (sz) {delete sz; sz=0;}
					if (img) {delete img; img=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				b_error=1; 
				return b_error;
				break;
		}	
	}
	
	
	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}
	
	return b_error;
	
}


//070806 - LSM file reading

int read_lsm_slice(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)
{
	if (TIFFIsTiled(in))
		return (read_lsm_slice_tile(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
	else
		return (read_lsm_slice_strip(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
}



int read_lsm_slice_strip(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)
{
	tsize_t bufsize  = TIFFStripSize(in);
	if ((pagepixelnumber*datatype)!=bufsize)
	{
		fprintf(stderr, "The current strip has a different size from the expected size in read_lsm_slice_strip(). No data is read.\n");
		return 1;
	}
	
	//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);
	
	/*
    uint8 * row = image->array;
	long width  = image->width;
	long height = image->height;
	long totalpixel=width*height; 
	*/

	//if (buf) {
	if (pointer_first_page) {
		tstrip_t s, ns = TIFFNumberOfStrips(in);
		uint32 *bytecounts;
		uint32 *stripoffsets;

		TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);
		
		TIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);

		for (s = 0; s < ns; s++) 
		{
			//printf("TIFFTAG_STRIPBYTECOUNTS and TIFFTAG_STRIPOFFSETS are [%d][%ld][%ld]\n", s, bytecounts[s], stripoffsets[s]); 
			//if (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, (tsize_t) -1)<0) 

			//if (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber)<0) //*datatype, 080301
			if (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber*datatype, pagepixelnumber*datatype)<0) //*datatype, 080301 to handle 12/16 bit LSM
			//if (phc_TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber)<0) 
			{
//				_TIFFfree(buf);
				//return (0);
				//(*in->tif_postdecode)(in, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber);
				continue;
			}
/*			else
			{
				unsigned char * curpt = ;
				long i;
				for (i=0;i<bufsize;i++)
				{
					*curpt++ = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806
				}
			}
			*/
		}
		//_TIFFfree(buf);
		return (1);
	}
	return 0;
}


int read_lsm_slice_tile(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)
{
	tsize_t bufsize = TIFFTileSize(in);
	if ((pagepixelnumber*datatype)!=bufsize)
	{
		fprintf(stderr, "The current tile has a different size from the expected size in read_lsm_slice_tile(). No data is read.\n");
		return 1;
	}
	
	//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);

	//if (buf) {
	if (pointer_first_page) {
		ttile_t t, nt = TIFFNumberOfTiles(in);
		uint32 *bytecounts;

		TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
		for (t = 0; t < nt; t++) 
		{
			//if (TIFFReadEncodedTile(in, t, buf, bytecounts[t]) < 0) 
			if (TIFFReadEncodedTile(in, t, pointer_first_page + long(t)*channelpixelnumber, bytecounts[t]) < 0) 
			{
//				_TIFFfree(buf);
				return (0);
			}
			/*
			else
			{
				long i;
				for (i=0;i<bufsize;i++)
				{
					row[i*3+s] = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806
				}
			}
			*/
		}
		//_TIFFfree(buf);
		return (1);
	}
	return 0;
}

int loadLsm2Stack(char * filename, unsigned char * & img, long * & sz, int & datatype)
{
	int berror=0;
	
	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;
	
	tif = Open_Tiff(filename,"r");
	if (!tif) 
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);
	
	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */
	
	tif = Open_Tiff(filename,"r");
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); 
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	
	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else 
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	long pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)  
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = depth;
		sz[3] = colorchannels;
		pixel_per_slice = long(width)*long(height);
		pixel_per_channel = pixel_per_slice*long(depth);
		ntotalpixel = pixel_per_channel*colorchannels;
	}
	
	if (img) {delete []img; img=0;}
	else 
	{
		img = new unsigned char [long(ntotalpixel)*long(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}
	
	// read every other directory (real data, the in between are thumbnails 
	long d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); 
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) 
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
			read_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);
		}
		
		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{ 
			if (!TIFFReadDirectory(tif)) break;	  /* skip the one we just read, it's a thumbnail  */
			if (!TIFFReadDirectory(tif)) break;	  /* get the next slice  */
		}
	}
	
	TIFFClose(tif);
	
	//return (stack);
	return berror;
}


int loadLsmThumbnail2Stack(char * filename, unsigned char * & img, long * & sz, int & datatype)
{
	int berror=0;
	
	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;
	
	tif = Open_Tiff(filename,"r");
	if (!tif) 
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);
	
	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */
	
	tif = Open_Tiff(filename,"r");

	TIFFReadDirectory(tif); //get to the first thumbnail image
//
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); 
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	
	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else 
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	long pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)  
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = depth;
		sz[3] = colorchannels;
		pixel_per_slice = long(width)*long(height);
		pixel_per_channel = pixel_per_slice*long(depth);
		ntotalpixel = pixel_per_channel*colorchannels;
	}
	
	if (img) {delete []img; img=0;}
	else 
	{
		img = new unsigned char [long(ntotalpixel)*long(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}
	
	// read every other directory (real data, the in between are thumbnails 
	long d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); 
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) 
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!",d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
			read_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);
		}
		
		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{ 
			if (!TIFFReadDirectory(tif)) break;	  /* skip the one we just read, it's a normal frame  */
			if (!TIFFReadDirectory(tif)) break;	  /* get the next thumbnail image  */
		}
	}
	
	TIFFClose(tif);
	
	return berror;
}

int loadLsmThumbnail2Stack_middle(char * filename, unsigned char * & img, long * & sz, int & datatype)
{
	int berror=0;
	
	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;
	
	tif = Open_Tiff(filename,"r");
	if (!tif) 
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);
	
	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */
	
	tif = Open_Tiff(filename,"r");
	TIFFReadDirectory(tif); //bypass a big image and get to the first thumbnail image
	
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); 
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else 
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	long pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)  
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = 1;
		sz[3] = colorchannels;
		pixel_per_slice = long(width)*long(height);
		pixel_per_channel = pixel_per_slice*long(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}
	
	if (img) {delete []img; img=0;}
	else 
	{
		img = new unsigned char [long(ntotalpixel)*long(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}
	
	// read every other directory (real data, the in between are thumbnails )
	
	long d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<=int(depth/2);d++)
	{
		if (d<int(depth/2))
		{
			TIFFReadDirectory(tif); //bypass a thumbnail 
			TIFFReadDirectory(tif); //bypass a big image
			continue;
		}
		
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); 
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) 
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
		    //note that as we onlky read one slice here, the "img+long(d)*long(pixel_per_slice)*long(datatype)" equals "img"
			read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
		}
		
		break; //after we read one slice, then stop;
	}
	
	TIFFClose(tif);
	
	return berror;
}

int loadLsm2Stack_middle(char * filename, unsigned char * & img, long * & sz, int & datatype)
{
	int berror=0;
	
	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;
	
	tif = Open_Tiff(filename,"r");
	if (!tif) 
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);
	
	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */
	
	tif = Open_Tiff(filename,"r");
	
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); 
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else 
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	long pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)  
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = 1;
		sz[3] = colorchannels;
		pixel_per_slice = long(width)*long(height);
		pixel_per_channel = pixel_per_slice*long(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}
	
	if (img) {delete []img; img=0;}
	else 
	{
		img = new unsigned char [long(ntotalpixel)*long(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}
	
	// read every other directory (real data, the in between are thumbnails )
	
	long d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<=int(depth/2);d++)
	{
		if (d<int(depth/2))
		{
			TIFFReadDirectory(tif); //bypass a big image 
			TIFFReadDirectory(tif); //bypass a thumbnail
			continue;
		}
		
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); 
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) 
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
		    //note that as we onlky read one slice here, the "img+long(d)*long(pixel_per_slice)*long(datatype)" equals "img"
			read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
		}
		
		break; //after we read one slice, then stop;
	}
	
	TIFFClose(tif);
	
	return berror;
}


int loadLsmSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)
{
	int berror=0;
	
	if (sliceno<-2)
	{
		fprintf(stderr, "The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\n");
		return 1; //070805, by Hanchuan Peng
	}
	
	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;
	
	tif = Open_Tiff(filename,"r");
	if (!tif) 
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsmSlice(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);
	
	printf("%d\n", depth/2);
	//printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */
	if (sliceno>depth-1) sliceno=depth-1; 
	//printf("slice #=%d\n", sliceno);
	
	tif = Open_Tiff(filename,"r");

	if (b_thumbnail)
		TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); 
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	
	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else 
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Slice(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	long pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)  
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = (sliceno==-2) ? depth : 1;
		sz[3] = colorchannels;
		pixel_per_slice = long(sz[1])*long(sz[0]);
		pixel_per_channel = pixel_per_slice*long(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}
	
	if (img) {delete []img; img=0;}
	else 
	{
		img = new unsigned char [long(ntotalpixel)*long(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}
	
	// read every other directory (real data, the in between are thumbnails 
    bool b_readnow=false;
	long d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		if (sliceno>-2)
		{
			if (sliceno==-1) //middle slice only
			{
				b_readnow=(d==int(depth/2))?true:false;
			}
			else
			{
				b_readnow=(d==sliceno)?true:false;
			}
		}
		else
		{
			b_readnow=true;
		}

		if (b_readnow)
		{
			TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
			TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
			TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); 
			TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

			//printf("d=%d, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

			if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) 
			{
				fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
				//in this case, do nothing to read the data and leave it empty
			}
			else
			{
				if (sliceno==-2)
				{
					read_lsm_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype), pixel_per_slice, pixel_per_channel, datatype);
				}
				else
				{
					read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
					break; //because only 1 read is needed in this case
				}
			}
		}
		
		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{ 
			if (!TIFFReadDirectory(tif)) break;	  /* one directory  */
			if (!TIFFReadDirectory(tif)) break;	  /* another directory */
		}
	}
	
	TIFFClose(tif);
	
	return berror;
}

//The following 3 functions are added on 2008-02-13
int loadTifSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail)
{
	int berror=0;
	
	if (sliceno<-2)
	{
		fprintf(stderr, "The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\n");
		return 1; 
	}
	
	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;
	
	tif = Open_Tiff(filename,"r");
	if (!tif) 
	{
		fprintf(stderr, "Cannot open the specified TIFF file in loadTifSlice(). \n");
		return 1; 
	}
	
	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);
	
	printf("%d\n", depth); //note that this sentence will be output an important info to use the pop_thumbnail php program
	//printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	//depth = depth / 2;		/* half the dirs are thumbnails */
	if (sliceno>depth-1) sliceno=depth-1; 
	//printf("slice #=%d\n", sliceno);
	
	tif = Open_Tiff(filename,"r");

	//if (b_thumbnail) TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels); 
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	
	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else 
	{
		fprintf(stderr, "TIF file should not support more than 16 bits data. Check the codes in loadTifSlice(). \n");
		return 1; //070805, by Hanchuan Peng
	}
	
	long pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new long [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)  
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = (sliceno==-2) ? depth : 1;
		sz[3] = colorchannels;
		pixel_per_slice = long(sz[1])*long(sz[0]);
		pixel_per_channel = pixel_per_slice*long(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}
	
	if (img) {delete []img; img=0;}
	else 
	{
		img = new unsigned char [long(ntotalpixel)*long(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}
	
	// read every other directory (real data, the in between are thumbnails 
    bool b_readnow=false;
	long d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		if (sliceno>-2)
		{
			if (sliceno==-1) //middle slice only
			{
				b_readnow=(d==int(depth/2))?true:false;
			}
			else
			{
				b_readnow=(d==sliceno)?true:false;
			}
		}
		else
		{
			b_readnow=true;
		}

		if (b_readnow)
		{
			TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
			TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
			TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels); 
			TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

			//printf("d=%d, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

			if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits) 
			{
				fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
				//in this case, do nothing to read the data and leave it empty
			}
			else
			{
				if (sliceno==-2)
				{
					read_tif_slice(tif, img+long(d)*long(pixel_per_slice)*long(datatype)*sz[3], width, height);
					//printf("Read No. %d slice.\n", d);
				}
				else
				{
					read_tif_slice(tif, img, width, height);
					//printf("width=[%d] height=[%d] color=[%d] bits-per-sample=[%d].\n", width, height, cur_colorchannels, cur_bits);
					//printf("Read No. %d slice.\n", d);
					//read_directory(tif,Select_Plane(stack,d),"Read_Stack");
					break; //because only 1 read is needed in this case
				}
			}
		}
		
		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{ 
			if (!TIFFReadDirectory(tif)) break;	  /* one directory  */
			//if (!TIFFReadDirectory(tif)) break;	  /* another directory */
		}
	}
	
	TIFFClose(tif);
	
	//debugging code: verification succeeds in Matlab reading code: 
	//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*3, 'uint8');a=reshape(a,[3 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)
			
	//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
	//fwrite(img, 3, width*height,tmp_fp);
	//fclose(tmp_fp);
	
	
	//produce thumbnail if required
	if (b_thumbnail)
	{
		long thumbsz0=128, thumbsz1=128;
		if (sz[0]>thumbsz0 || sz[1]>thumbsz1)
		{	
			unsigned char * img1 = new unsigned char [long(thumbsz0)*thumbsz1*sz[2]*sz[3]*long(datatype)];
			unsigned char ****img4d1 = 0;
			new4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2], img1);
	
			unsigned char ****img4d = 0;
			new4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img);
			
			double factor_jj=sz[1]/thumbsz1, factor_ii=sz[0]/thumbsz0;
			for (long kk=0;kk<sz[2];kk++)
			{
				for (long jj=0; jj<thumbsz1; jj++)
				{
					for (long ii=0;ii<thumbsz0; ii++)
					{
						for (long cc=0;cc<sz[3];cc++)
						{
							img4d1[kk][jj][ii][cc] = img4d[kk][long(floor(jj*factor_jj))][long(floor(ii*factor_ii))][cc];
						}
					}
				}
			}
			
			delete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);
			delete4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2]);

			delete []img;
			img = img1;
			sz[0] = thumbsz0;
			sz[1] = thumbsz1;
			//sz[2] and sz[3] do not need change
		}
	}

	//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
	//fwrite(img, 3, width*height,tmp_fp);
	//fclose(tmp_fp);
	
	//permute the data to make sure it will be output correctly
	unsigned char ****img4d = 0;
	new4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img); //must realize this order!
	
	unsigned char * img1 = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];
	unsigned char ****img4d1 = 0;
	new4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3], img1);
	
	for (long tcc=0;tcc<sz[3];tcc++)
	{
		for (long tkk=0;tkk<sz[2];tkk++)
		{
			for (long tjj=0;tjj<sz[1];tjj++)
			{
				for (long tii=0;tii<sz[0];tii++)
				{
					img4d1[tcc][tkk][tjj][tii] = img4d[tkk][tjj][tii][tcc];
				}
			}
		}
	}
	
	delete4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3]);
	delete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);
	if (img) {delete []img; img=0;}
	img = img1;
	
	return berror;
}

int read_tif_slice(TIFF *tif, unsigned char * pointer_first_page, long width, long height) 
//note that this is not a general tif slice reader, - but should work for date generated using Gene's code
{
	//	if (TIFFIsTiled(in))
	//		return (read_tif_slice_tile(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
	//	else
	//		return (read_tif_slice_strip(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
	
	//
	
	//first determine the image type
	
	enum PImagePixelType {PTIF_GREY, PTIF_GREY16, PTIF_COLOR};
	PImagePixelType pixelType;
	
	
	short bits, channels, photo;
	
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);
	TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photo);
	if (photo <= 1)
    {
		if (channels > 1)
			fprintf(stderr, "Black and white tiff has more than 1 channel!");
		if (bits == 16)
			pixelType = PTIF_GREY16;
		else
			pixelType = PTIF_GREY;
    }
	else
		pixelType = PTIF_COLOR;
	
	// then read data
	
	uint32 *raster = new uint32 [width*height];
	if (!raster)
	{
		fprintf(stderr, "Fail to allocate memory in read_tif_slice();\n");
		return 1;
	}
	
	unsigned char  *row;
	
	row = pointer_first_page;
	
	if (pixelType != PTIF_GREY16)
    {
		int i, j;
		uint32 *in;
		uint8  *out;
		
		if (TIFFReadRGBAImage(tif,width,height,raster,0) == 0)
		{
			fprintf(stderr, "read of tif failed");
			if (raster) {delete []raster; raster=0;}
			return 1;
		}
	
		//debugging code: verification succeeds in Matlab reading code: 
		//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*4, 'uint8');a=reshape(a,[4 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)
				
		//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
		//fwrite(raster, 4, width*height,tmp_fp);
		//fclose(tmp_fp);
		
		in = raster;
		if (pixelType == PTIF_GREY)
        {
			for (j = height-1; j >= 0; j--)
			{
				out = row;
				for (i = 0; i < width; i++)
				{
					uint32 pixel = *in++;
					*out++ = TIFFGetR(pixel);
				}
				row += width;
			}
        }
		else
        {
			for (j = height-1; j >= 0; j--)
			{
				out = row;
				for (i = 0; i < width; i++)
				{ 
					uint32 pixel = *in++;
					*out++ = TIFFGetR(pixel);
					*out++ = TIFFGetG(pixel);
					*out++ = TIFFGetB(pixel);
				}
				row += width*3;
			}
        }
    }
	
	else
		
    { 
		int tile_width, tile_height;
		
		if (TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width))    // File is tiled  
        { int x, y;
			int i, j;
			int m, n;
			uint16 *buffer = (uint16 *) raster;
			uint16 *out, *in; //, *rous;
			
			TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);
			
			for (y = 0; y < height; y += tile_height)
            { if (y + tile_height > height)
                n = height - y;
				else
					n = tile_height;
				for (x = 0; x < width; x += tile_width)
                { TIFFReadTile(tif, buffer, x, y, 0, 0);
					if (x + tile_width > width)
						m = width - x;
					else
						m = tile_width;
					for (j = 0; j < n; j++)
                    { out = (uint16 *) (row + 2*(j*width + x));
						in  = buffer + j*tile_width;
						for (i = 0; i < m; i++)
							*out++ = *in++; 
                    }
                }
				row += n*width*2;
            }
        }
		
		else    // File is striped
			
        { int     y;
			
			for (y = 0; y < height; y++)
            { TIFFReadScanline(tif, row, y, 0);
				row += width*2;
            }
        }
    }
	
	if (raster) {delete []raster; raster=0;}
	//
	return 0;
	//
	
}



int read_tif_slice_strip(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)
{
	tsize_t bufsize  = TIFFStripSize(in);
	if (pagepixelnumber!=bufsize)
	{
		fprintf(stderr, "The current strip has a different size [%ld] from the expected size [%ld] in read_tif_slice_strip(). No data is read.\n", long(bufsize), pagepixelnumber);
		return 1;
	}
	
	if (pointer_first_page) {
		tstrip_t s, ns = TIFFNumberOfStrips(in);
		uint32 *bytecounts;
		uint32 *stripoffsets;

		TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);
		
		TIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);

		for (s = 0; s < ns; s++) 
		{
			if (TIFFReadEncodedStrip(in, s, pointer_first_page + long(s)*channelpixelnumber, pagepixelnumber)<0) 
			{
				continue;
			}
		}
		return (1);
	}
	return 0;
}


int read_tif_slice_tile(TIFF *in, unsigned char * pointer_first_page, long pagepixelnumber, long channelpixelnumber, int datatype)
{
	tsize_t bufsize = TIFFTileSize(in);
	if (pagepixelnumber!=bufsize)
	{
		fprintf(stderr, "The current tile has a different size from the expected size in read_tif_slice_tile(). No data is read.\n");
		return 1;
	}
	
	if (pointer_first_page) {
		ttile_t t, nt = TIFFNumberOfTiles(in);
		uint32 *bytecounts;

		TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
		for (t = 0; t < nt; t++) 
		{
			if (TIFFReadEncodedTile(in, t, pointer_first_page + long(t)*channelpixelnumber, bytecounts[t]) < 0) 
			{
				return (0);
			}
		}
		return (1);
	}
	return 0;
}


int loadRawSlice(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}

int loadRawSlice_2byte(char * filename, unsigned char * & img, long * & sz, int & datatype, long sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}


//070214: add a simple interface to read and save all supported file formats

bool ensure_file_exists_and_size_not_too_big(char *filename, long sz_thres)
{
	FILE * fid = fopen(filename, "rb");
	if (!fid) 
	{
		printf("The file [%s] does not exist or cannot be read.\n", filename);
		return false;
	}
	
	fseek (fid, 0, SEEK_END);
	long fileSize = ftell(fid);
	rewind(fid);
	fclose(fid);
	
	if(fileSize>sz_thres)
	{
		printf("The file [%s] has a too big size [= %ld bytes ] > [%ld bytes] which is the limit of the loadImage function. Do nothing. \n", filename, fileSize, sz_thres);
		return false;
	}
	
	return true;
}

bool loadImage(char imgSrcFile[], unsigned char *& data1d, long * &sz, int & datatype)
{
	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}
	else
	{
		sz = new long [4];
		if (!sz)
		{
			printf("Fail to alocate memory for the size variable.\n");
			return false;
		}
	}
	
	unsigned char *tmp_data1d =0;
	long * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;
	
    char * curFileSuffix = getSuffix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
	if (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0) //read tiff stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (long)1024*1024*900)) //tif file at most should be 900M bytes
		{
			printf("The tif file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadTif2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in TIF file reading. Stop. \n");
			return false;
		}
	}
	else if ( strcasecmp(curFileSuffix, "lsm")==0 ) //read lsm stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (long)1024*1024*900)) //lsm file at most should be 900M bytes
		{
			printf("The lsm file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadLsm2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in LSM file reading. Stop. \n");
			return false;
		}
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (long)1024*1024*1500)) //RAW file at most should be 1.5G bytes
		{
			printf("The RAW file may not exist or may be too big to load.\n");
			return false;
		}
		
		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}   
		}
	}
	
	
	//copy output data
	
	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;
			
		case 2:
			datatype = 2;
			break;
			
		case 4:
			datatype = 4;
			break;
			
		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
				if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
				if (sz) {delete []sz; sz=0;}
				return false;
	}
	
	sz = new long [4];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	
	data1d = tmp_data1d;
	
	/* clean all workspace variables */
	
	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
	
	return true;
}

bool saveImage(const char filename[], const unsigned char * data1d, const long * sz, const int datatype)
{
	if (!data1d || !filename || !sz)
	{
		printf("This image data is empty or the file name or the size pointer is invalid. Nothing done.\n"); 
		return false;
	}	
	
	int dt;
	switch (datatype)
	{
		case 1:  dt=1; break;
		case 2:  dt=2; break;
		case 4:  dt=4; break;
		default: 
			printf("The data type is unsupported. Nothing done.\n"); 
			return false;
			break;
	}
  	
    char * curFileSuffix = getSuffix((char *)filename);
    if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
	if (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0) //read tiff stacks
	{
		if (saveStack2Tif(filename, data1d, sz, dt))
		{
			printf("Error happens in writing TIF file [%s]. Stop. \n", filename);
			return false;
		}
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
		if (saveStack2Raw(filename, data1d, sz, dt)!=0) //0 is no error //note that as I updated the saveStack2Raw to RAW-4-byte, the actual mask file cannot be read by the old wano program, i.e. the wano must be updated on Windows machine as well. 060921 
		{
			printf("Error happens in writing RAW file stack [defined by Hanchuan Peng] [%s].\n", filename);
			return false;
		}
	}
	
	
	return true;
}


#endif //__STACKUTIL_CPP__


