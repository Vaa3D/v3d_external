/*
 * Copyright (c)2006-2010  Hanchuan Peng (Janelia Farm, Howard Hughes Medical Institute).  
 * All rights reserved.
 */


/************
                                            ********* LICENSE NOTICE ************

This folder contains all source codes for the V3D project, which is subject to the following conditions if you want to use it. 

You will ***have to agree*** the following terms, *before* downloading/using/running/editing/changing any portion of codes in this package.

1. This package is free for non-profit research, but needs a special license for any commercial purpose. Please contact Hanchuan Peng for details.

2. You agree to appropriately cite this work in your related studies and publications.

Peng, H., Ruan, Z., Long, F., Simpson, J.H., and Myers, E.W. (2010) “V3D enables real-time 3D visualization and quantitative analysis of large-scale biological image data sets,” Nature Biotechnology, Vol. 28, No. 4, pp. 348-353, DOI: 10.1038/nbt.1612. ( http://penglab.janelia.org/papersall/docpdf/2010_NBT_V3D.pdf )

Peng, H, Ruan, Z., Atasoy, D., and Sternson, S. (2010) “Automatic reconstruction of 3D neuron structures using a graph-augmented deformable model,” Bioinformatics, Vol. 26, pp. i38-i46, 2010. ( http://penglab.janelia.org/papersall/docpdf/2010_Bioinfo_GD_ISMB2010.pdf )

3. This software is provided by the copyright holders (Hanchuan Peng), Howard Hughes Medical Institute, Janelia Farm Research Campus, and contributors "as is" and any express or implied warranties, including, but not limited to, any implied warranties of merchantability, non-infringement, or fitness for a particular purpose are disclaimed. In no event shall the copyright owner, Howard Hughes Medical Institute, Janelia Farm Research Campus, or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; reasonable royalties; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.

4. Neither the name of the Howard Hughes Medical Institute, Janelia Farm Research Campus, nor Hanchuan Peng, may be used to endorse or promote products derived from this software without specific prior written permission.

*************/




/*
 *  stackutil.cpp
 *
 *
 *  Created (extracted from earlier codes) by Hanchuan Peng on 7/31/06.
 *  Modified on 060803 by Hanchuan Peng: change the size information to be 4 V3DLONG (4-byte) instead of 4-short-int (2byte).
 *  Updated 060806: correct a bug in 4-byte swapping. And notice the compatibility of 32-bit system and 64-bit system about the length of int/V3DLONG types
 *  Copyright 2006 __Hanchuan Peng__. All rights reserved.
 *
 *  060816: add tif support
 *  060828: add surfix extraction function here
 *
 *  060920: add 2-byte formatted raw format support back to increase the compatibility of existing data in the worm project
 *
 *  070214: add two simple interface to read any file formats supported (raw or tif) based on the surfix of filename
 *  070220: add b_VERBOSE_PRINT
 *  070306: add tif file exist verification
 * 070713: George tried to add lsm file reading functions but unsucecssful
 * 070806: Hanchuan added lsm 8-bit reading functions
 * 070807/08: try to handle the imcomplete data generated by the Zeiss lsm writer. The current solution is to change the a function in libtiff tif_lzw.c file
 *            and force it return the value 2, instead of 0, when the input strip size is bigger than real. In this way, the tif function TIFFReadEncodedStrip()
 *            will continue to do postprocessing of the already read data.
 *
 *            Special note: in this way, I will have to build a customary libtiff library and install at my own location ~/work/3rdsoft/lib instead of
 *                          the default /usr/local/lib. When I will have to reset the .bashrc/.profile file and use LD_LIBRARY_PATH (and probably also DYLD_LIBRARY_PATH)
 *                          for Mac to link them. This works for the case of V3D already. However, interestingly, I read an article arguing that using otool/ldd/nm, the dependency
 *                          of objects files can be seen, and that Mac uses the absolute path in library dependency, and that LD_LIBRARY_PATH does not work. The
 *                          interesting thing is that after I tried both, I found otool does show the absolute path, but LD_LIBARY_PATH/DYLD_LIBRARY_PATH works!
 *
 * 070819: add several functions to read LSM file thumbnails and middle slice.
 * 071125: update the copy on my G4 Mac so that it use CPP interface to Gene's codes instead of the C interface
 * 080103: add some further verbose printing
 * 20080213: add interface functions to read single slice of a tiff stack, or the respective thumbnail: Note that the lsm and tif interfaces are DIfferent!
 * 20080301: add handling of 12/16 bit LSM
 * 20080302: change the include "basic_memory.h" to .cpp, due to the template instantiation in V3D
 * 20080401: add the ifndef tag as this will often be included in other files
 * 20080828: add file size limitation, so avoid loading too big file that may cause the tif reader to crash
 * 20080930: return the original tiff pixel value but not the automatically scaled down version
 * 20081204: add overload functions to read only a channel of a stack
 * 20090413: add simple MRC file reading and writing
 * 20090802: add raw5d read/write
 * 20100520: try to revise ZZBIG to allow big file, also add fstat check for windows large file size , instead of using fseek and ftell
 * 20100816: add mylib interface, by PHC.
 * 20110708: fix a memory leak (non-crashing) of redudnant memory allocation of a sz variable
 * 20110804: fix a new Mac fread issue to read more than 2G data in one call (I don't believe I saw this on the old Leopard 64 bit Mac Pro desktop, as we (both Zongcai and I should have) 
 *           benched tested the >3G v3draw file read. This problem is not found for Linux 64bit. Is that a new Mac std libc bug?? 
 *           Anyway, I have now used a 2G buffer to read >2G data. I have not changed the saveStack2Raw functions. It seems they work in the Matlab mex functions. Thus I assumed
 *           they don't need to change. Need tests anyway.
 * 20120410: fix a bug when strcasecmp_l() taking a NULL parameter so that it crashes
 */

#define _FILE_OFFSET_BITS  64  //20140919

#ifndef __STACKUTIL_CPP__
#define __STACKUTIL_CPP__



// 64-bit and 32-bit checking
// Windows
#if _WIN32 || _WIN64
#if _WIN64
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

// GCC
#if __GNUC__
#if __x86_64__ || __ppc64__
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

//#include "../elementmexheader.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#include "stackutil.h"
#include "basic_memory.cpp" //change basic_memory.h to basic_memory.cpp, 080302

/*
extern "C" {
*/
#include "mg_image_lib.h"
/*
};
*/

//#define _ALLOW_WORKMODE_MENU_    //indeed this seems not really working well, as many plugins need to add additional src files, noted PHC, 20130127

#ifdef _ALLOW_WORKMODE_MENU_
#include "../neuron_annotator/utility/ImageLoaderBasic.h"
#endif


#define b_VERBOSE_PRINT 1
#define ZZBIG 320000 //previous I define it as 1500, so that to limit the size of an image is at most 1.5G //change 2010-05-21 // hang 2011-08-25 6000->10000

#ifdef _MSC_VER       //2010-05-21, by PHC
#include <sys/stat.h>
#include <io.h>
#endif

#define DEFINE_NBYTE2G \
  V3DLONG nBytes2G = (V3DLONG(1024)*V3DLONG(1024)*V3DLONG(1024)-1)*V3DLONG(2);


//int b_VERBOSE_PRINT=1;
/* a simple surfix function.*/

const char * getSuffix(const char *filename)
{
	if (!filename)
		return 0;

	V3DLONG i=0,k=-1;
	while (filename[i]!='\0')
	{
		if (filename[i]=='.')
			k=i;
		i++;
	}

	if (k==-1 || k==i)
		return 0;

	return (filename+k+1);
}


/* The following is the core function for image stack reading of 2 byte raw*/

int loadRaw2Stack_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	
	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = V3DLONG(unitSize)*V3DLONG(totalUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	V3DLONG remainingBytes = totalBytes;

    DEFINE_NBYTE2G
	
    V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;
		V3DLONG curReadUnits = curReadBytes/unitSize;
		nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid);
		if (nread!=curReadUnits)
		{
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;
        printf("Finish reading %5.4f%%\r", (1-double(remainingBytes)/(double(totalBytes)))*100.0); fflush(stdout);
        cntBuf++;
	}
	
	
	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


int loadRaw2Stack_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //overload for convenience to read only 1 channel
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}

	//081204
	if (chan_id_to_load<0 || chan_id_to_load>=mysz[3])
	{
                printf("The specified chan_id_to_load [=%d] is out of the valid of the image data [=%d] \n", chan_id_to_load, mysz[3]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, channelUnit=1;
	for (i=0;i<3;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		channelUnit *= sz[i];
	}
	sz[3] = 1; //this must be true in case only one channel is read
	totalUnit = channelUnit*mysz[3];

	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = V3DLONG(unitSize)*V3DLONG(channelUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack_2byte().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	if (chan_id_to_load>0) //other no need to call the function
		fseek(fid, channelUnit*chan_id_to_load*unitSize, SEEK_CUR);

	V3DLONG remainingBytes = totalBytes;
    
    DEFINE_NBYTE2G
	
	V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;
		V3DLONG curReadUnits = curReadBytes/unitSize;
		nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid);
		if (nread!=curReadUnits)
		{
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;
        printf("Finish reading %5.4f%%\r", (1-double(remainingBytes)/(double(totalBytes))*100.0)); fflush(stdout);
        cntBuf++;
	}

	
	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


/* The following is the core function for image stack writing of 2-byte raw*/

int saveStack2Raw_2byte(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	//if (b_swap)  {
	for (i=0;i<4;i++) mysz[i] = (short int) sz[i];
	//swap2bytes((void *)(mysz+i));
	//}
	nwrite = fwrite(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
if (nwrite!=4)
{
    printf("Writing file error.\n");
    berror = 1;
    return berror;
}

V3DLONG totalUnit = 1;
for (i=0;i<4;i++)
{
    totalUnit *= sz[i];
}

nwrite = fwrite(img, unitSize, totalUnit, fid);
if (nwrite!=totalUnit)
{
    printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
    berror = 1;
    return berror;
}

/* swap the data bytes if necessary */
/*
 if (b_swap==1)
 {
	 if (unitSize==2)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap2bytes((void *)(img+i*unitSize));
		 }
	 }
	 else if (unitSize==4)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap4bytes((void *)(img+i*unitSize));
		 }
	 }
 }
 */


/* clean and return */

fclose(fid);

return berror;
}

/* The following is the core function for image stack reading */

int loadRaw2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
		//mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
          sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	/*
#ifdef _MSC_VER
	struct stat stbuf;
	int myfd;
	myfd = open(filename, O_RDONLY);
	if (myfd<0) 
	{
		printf("Fail to use open() for this file. \n");
		berror=1;
		return berror;
	}
	FILE * fid = fdopen(myfd, "rb");
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	if (fstat(myfd, &stbuf) == -1)
	{
		printf("Fail to get the file status. \n");
		berror=1;
		return berror;
	}
	V3DLONG fileSize = stbuf.st_size;
#else
*/
	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
/*
#endif
*/
	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if (fileSize<lenkey+2+4*4+1) // datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. 
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		printf("The fseek-ftell produces a file size = %ld.", fileSize);
		berror = 1;
		return berror;
	}
#endif

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	printf("The data endian code is [%c]\n", endianCodeData);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine;
	endianCodeMachine = checkMachineEndian();
	printf("The machine endian code is [%c]\n", endianCodeMachine);
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; // temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. 

	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); // because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. 
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; // reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. 
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

		//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
#endif

	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = V3DLONG(unitSize)*V3DLONG(totalUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	V3DLONG remainingBytes = totalBytes;
    
    DEFINE_NBYTE2G

    printf("\n");
	V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;

//        V3DLONG curReadUnits = curReadBytes/unitSize; //no need to use, 2014-9-21

        //nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid); //this seems to be the bug in the unable to read >2G float data, 20140921, by PHC
        nread = fread(img+cntBuf*nBytes2G, 1, curReadBytes, fid); // a fix of the bug for ">2G float data " reading,. seems there is a bug in fread()!!!

         printf("Just read %ld units, each unit has the size = %ld\n", nread/unitSize, unitSize);   fflush(stdout);

//		if (nread!=curReadUnits)
        if (nread!=curReadBytes) //20140921. by PHC
        {
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;

//        printf("Finish reading %5.4f%% \r", (1-double(remainingBytes)/(double(totalBytes)))*100.0); fflush(stdout);
        if (remainingBytes>0)
        {
            printf("Finish reading %5.4f%% \n", (1-double(remainingBytes)/(double(totalBytes)))*100.0);
            fflush(stdout);
        }
        else
        {
            printf("Finish reading 100%% \n");
            fflush(stdout);
        }

		cntBuf++;
	}

	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}
	else
	{
      printf("No swapping of data. \n");
	}


	// clean and return 

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

    if (b_VERBOSE_PRINT && 0)
    {
        //a debug check of the min max value
        switch (dcode)
        {
        case 1:
        {
            unsigned char *img1 = img;
            float minvv=img1[0], maxvv=img1[0];
            for (V3DLONG myii=1; myii<totalUnit;myii++)
            {
                if (minvv>img1[myii]) minvv=img1[myii];
                else if (maxvv<img1[myii]) maxvv=img1[myii];
            }
            printf("*** for loadRaw2Stack() all readin units: [minvv=%5.3f maxvv=%5.3f]\n", minvv, maxvv);
        }
            break;

        case 2:
        {
            unsigned short int *img1 = (unsigned short int *)img;
            float minvv=img1[0], maxvv=img1[0];
            for (V3DLONG myii=1; myii<totalUnit;myii++)
            {
                if (minvv>img1[myii]) minvv=img1[myii];
                else if (maxvv<img1[myii]) maxvv=img1[myii];
            }
            printf("*** for loadRaw2Stack() all readin units: [minvv=%5.3f maxvv=%5.3f]\n", minvv, maxvv);
        }
            break;

        case 4:
        {
            float *img1 = (float *)img;
            float minvv=img1[0], maxvv=img1[0];
            for (V3DLONG myii=1; myii<totalUnit;myii++)
            {
                if (minvv>img1[myii]) minvv=img1[myii];
                else if (maxvv<img1[myii]) maxvv=img1[myii];
            }
            printf("*** for loadRaw2Stack() all readin units: [minvv=%5.3f maxvv=%5.3f]\n", minvv, maxvv);
        }
            break;

        default:
            printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
            if (keyread) {delete []keyread; keyread=0;}
            berror = 1;
            return berror;
        }
    }

	return berror;
}

int loadRaw2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*4+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[4];//060806
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	//081204
	if (chan_id_to_load<0 || chan_id_to_load>=mysz[3])
	{
                printf("The specified chan_id_to_load [=%d] is out of the valid of the image data [=%d] \n", chan_id_to_load, mysz[3]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, channelUnit=1;
	for (i=0;i<3;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		channelUnit *= sz[i];
	}
	sz[3] = 1; //this must be true in case only one channel is read
	totalUnit = channelUnit*mysz[3];

	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = V3DLONG(unitSize)*V3DLONG(channelUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack_2byte().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	if (chan_id_to_load>0) //other no need to call the function
		fseek(fid, channelUnit*chan_id_to_load*unitSize, SEEK_CUR);
	
	V3DLONG remainingBytes = totalBytes;
    
    DEFINE_NBYTE2G
	
	V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;

        //the following is changed on 2014-09-21 consistent with the loadRaw2Stack() function to fix the big (>2G) float data reading bug seemingly in fread(). by PHC

//		V3DLONG curReadUnits = curReadBytes/unitSize;
//		nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid);
//		if (nread!=curReadUnits)

        nread = fread(img+cntBuf*nBytes2G, 1, curReadBytes, fid);
        if (nread!=curReadBytes)
        {
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;
        printf("Finish reading %5.4f%%\r", (1-double(remainingBytes)/(double(totalBytes)))*100.0); fflush(stdout);
        cntBuf++;
	}
	
	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


/* The following is the core function for image stack writing */

int saveStack2Raw(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

    nwrite=fwrite(&dcode, 2, 1, fid);
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	//short int mysz[4];
    BIT32_UNIT mysz[4];
    for (i=0;i<4;i++) mysz[i] = (BIT32_UNIT) sz[i];
    nwrite = fwrite(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=4)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		totalUnit *= sz[i];
	}

	nwrite = fwrite(img, unitSize, totalUnit, fid);
	if (nwrite!=totalUnit)
	{
		printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
		berror = 1;
		return berror;
	}

	/* clean and return */

	fclose(fid);

	return berror;
}


int loadRaw5d2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
    /* This function reads 2-5D image stack from v3d raw5 data */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*5+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=mysz[4]=0;
	int tmpn=fread(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=5)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<5;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [5]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<5;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	if ((totalUnit*unitSize+4*5+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*5+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3], sz[4]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3], mysz[4]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}

int loadRaw5d2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int stack_id_to_load)
{
    /* This function reads 2-5D image stack from v3d raw5 data . */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*5+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=mysz[4]=0;
	int tmpn=fread(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<5;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (stack_id_to_load<0 || stack_id_to_load>=mysz[4])
	{
                printf("The specified stack_id_to_load [=%d] is out of the valid of the image data [=%d] \n", stack_id_to_load, mysz[4]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [5]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, stackUnit=1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		stackUnit *= sz[i];
	}
	sz[4] = 1; //this must be true in case only one channel is read
	totalUnit = stackUnit*mysz[4];

	if ((totalUnit*unitSize+4*5+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*5+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3], sz[4]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3], mysz[4]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [stackUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (stack_id_to_load>0) //other no need to call the function
		fseek(fid, stackUnit*stack_id_to_load*unitSize, SEEK_CUR);
	nread = fread(img, unitSize, stackUnit, fid);
	if (nread!=stackUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, stackUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<stackUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<stackUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid);

	return berror;
}

int saveStack2Raw5d(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];//090802
	for (i=0;i<5;i++) mysz[i] = (BIT32_UNIT) sz[i];
	nwrite = fwrite(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=5)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<5;i++)
	{
		totalUnit *= sz[i];
	}

	nwrite = fwrite(img, unitSize, totalUnit, fid);
	if (nwrite!=totalUnit)
	{
		printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
		berror = 1;
		return berror;
	}

	/* clean and return */

	fclose(fid);

	return berror;
}


/* check the machine endianness */

char checkMachineEndian()
{
    char e='N'; //for unknown endianness

    V3DLONG int a=0x44332211;
    unsigned char * p = (unsigned char *)&a;
    if ((*p==0x11) && (*(p+1)==0x22) && (*(p+2)==0x33) && (*(p+3)==0x44))
        e = 'L';
    else if ((*p==0x44) && (*(p+1)==0x33) && (*(p+2)==0x22) && (*(p+3)==0x11))
        e = 'B';
    else if ((*p==0x22) && (*(p+1)==0x11) && (*(p+2)==0x44) && (*(p+3)==0x33))
        e = 'M';
    else
        e = 'N';

    //printf("[%c] \n", e);
    return e;
}


void swap2bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+1);
    *(tp+1) = a;
}

void swap4bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+3);
    *(tp+3) = a;
    a = *(tp+1);
    *(tp+1) = *(tp+2);
    *(tp+2) = a;
}


int loadTif2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //overload for convenience to read only 1 channel
{
	if (chan_id_to_load<0) {fprintf(stderr, "Chan_id_to_load < 0. Do nothing\n"); int b_error=1; return b_error;}
	int val_return = loadTif2Stack(filename, img, sz, datatype);
	if (chan_id_to_load>=sz[3]) {fprintf(stderr, "Chan_id_to_load > # of data color channels. force chan_id_to_load to be the last channel\n"); chan_id_to_load=sz[3]-1;}
	if (sz[3]==1) return val_return;
	else
	{
		V3DLONG chanel_bytes = V3DLONG(sz[0])*sz[1]*sz[2]*datatype;
		if (chan_id_to_load>0) //otherwise no need to do this
			memcpy(img, img+chanel_bytes*chan_id_to_load, chanel_bytes);
		realloc(img, chanel_bytes); //shrink download the memory used
		sz[3]=1;
		return val_return;
	}
}

int loadLsm2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load)   //overload for convenience to read only 1 channel
{
	if (chan_id_to_load<0) {fprintf(stderr, "Chan_id_to_load < 0. Do nothing\n"); int b_error=1; return b_error;}
	int val_return = loadLsm2Stack(filename, img, sz, datatype);
	if (chan_id_to_load>=sz[3]) {fprintf(stderr, "Chan_id_to_load > # of data color channels. force chan_id_to_load to be the last channel\n"); chan_id_to_load=sz[3]-1;}
	if (sz[3]==1) return val_return;
	else
	{
		V3DLONG chanel_bytes = V3DLONG(sz[0])*sz[1]*sz[2]*datatype;
		if (chan_id_to_load>0) //otherwise no need to do this
			memcpy(img, img+chanel_bytes*chan_id_to_load, chanel_bytes);
		realloc(img, chanel_bytes); //shrink download the memory used
		sz[3]=1;
		return val_return;
	}
}

int loadTif2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int b_error=0;

    try //120329
    {
	//fprintf(stderr, "Verify file existence.\n");
	FILE *tmp = fopen(filename, "r");
	if (!tmp) {fprintf(stderr, "The file [%s] does not exist.\n", filename); b_error=1; return b_error;}
	else {fclose(tmp);}

	//the following are the interface codes

	Stack *tmpstack = Read_Stack(filename);
	if (!tmpstack)
	{
		b_error=1;
		return b_error;
	}

	//convert to hanchuan's format
	if (sz) {delete sz; sz=0;}
	if (img) {delete img; img=0;}

	sz=new V3DLONG [4];
	if (sz)
	{
		sz[0] = tmpstack->width;
		sz[1] = tmpstack->height;
		sz[2] = tmpstack->depth;
		switch (tmpstack->kind)
		{
			case GREY:
				sz[3] = 1;
				datatype = 1;
				break;

			case GREY16:
				sz[3] = 1;
				datatype = 2;
				break;

			case COLOR:
				sz[3] = 3;
				datatype = 1;
				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				break;
		}
	}
	else
	{
		printf("Unable to allocate memory for the size varable! Return.\n");
		if (tmpstack)
		{
			Kill_Stack(tmpstack);
			tmpstack=0;
		}
		b_error=1;
		return b_error;
	}

	img = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]*datatype];
	if (!img)
	{
		printf("Unable to allocate memory for the image varable! Return.\n");
		if (tmpstack)	  {	Kill_Stack(tmpstack);	tmpstack=0;}
		if (sz) {delete sz; sz=0;}
		b_error=1;
		return b_error;
	}
	else
	{
		V3DLONG i,j,k,c;
		V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];

		switch (tmpstack->kind)
		{
			case GREY:
			case COLOR:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c);

				break;

			case GREY16:
				{
					unsigned short int *img16 = (unsigned short int *)img;
					for (c=0;c<sz[3];c++)
						for (k=0;k<sz[2]; k++)
							for (j=0;j<sz[1]; j++)
								for (i=0;i<sz[0]; i++)
									//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
									//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
									img16[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c); //do not assume anything. 080930
				}

				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					if (img) {delete img; img=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				b_error=1;
				return b_error;
				break;
		}
	}


	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}
    }
 catch (...) {
     printf("An exception is caught for tiff file reading.\n");
     b_error=1;
}


	return b_error;

}

int saveStack2Tif(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	int b_error=0;

	int i,j,k,c;
	for (i=0;i<4;i++)
	{
		if (sz[i]<0)
		{
			printf("The %d sz parameter is not valid [%ld]. Exit.\n", i, sz[i]);
			b_error=1;
			return b_error;
		}
	}

	if (!img)
	{
		printf("The input image pointer is null. Exit.\n");
		b_error=1;
		return b_error;
	}

	int kind;
	if (sz[3]==1)
		kind = GREY;
	else //if (sz[3]>1) //but only output the 3 first channels
		kind = COLOR;

	Stack *tmpstack = Make_Stack(kind, int(sz[0]), int(sz[1]), int(sz[2]));
	if (!tmpstack)
	{
		printf("Fail to allocate memory for tif output.\n");
		b_error=1;
		return b_error;
	}

	V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];
	for (c=0;c<sz[3];c++)
		for (k=0;k<sz[2]; k++)
			for (j=0;j<sz[1]; j++)
				for (i=0;i<sz[0]; i++)
					Set_Stack_Pixel(tmpstack,i,j,k,c, img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i]);

	//output to file
	Write_Stack((char*)filename, tmpstack);

	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}

	return b_error;
}


int loadLsm2Stack_obsolete(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) //070713
{
	int b_error=0;

	//070306: verify the file exists: Note that for some reasons, the printf() output does not show up in Matlab (mex file) but completely normal for other C executable (like laff). Strange.

	//fprintf(stderr, "Verify file existence.\n");
	FILE *tmp = fopen(filename, "r");
	if (!tmp) {fprintf(stderr, "The file [%s] does not exist.\n", filename); b_error=1; return b_error;}
	else {fclose(tmp);}


	//the following are the interface codes

	Stack *tmpstack = Read_LSM_Stack(filename);
	if (!tmpstack)
	{
		b_error=1;
		return b_error;
	}

	//convert to hanchuan's format
	if (sz) {delete sz; sz=0;}
	if (img) {delete img; img=0;}

	sz=new V3DLONG [4];
	if (sz)
	{
		sz[0] = tmpstack->width;
		sz[1] = tmpstack->height;
		sz[2] = tmpstack->depth;
		switch (tmpstack->kind)
		{
			case GREY:
				sz[3] = 1;
				datatype = 1;
				break;

			case GREY16:
				sz[3] = 1;
				datatype = 1;
				break;

			case COLOR:
				sz[3] = 3;
				datatype = 1;
				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				break;
		}
	}
	else
	{
		printf("Unable to allocate memory for the size varable! Return.\n");
		if (tmpstack)
		{
			Kill_Stack(tmpstack);
			tmpstack=0;
		}
		b_error=1;
		return b_error;
	}

	img = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];
	if (!img)
	{
		printf("Unable to allocate memory for the image varable! Return.\n");
		if (tmpstack)	  {	Kill_Stack(tmpstack);	tmpstack=0;}
		if (sz) {delete sz; sz=0;}
		b_error=1;
		return b_error;
	}
	else
	{
		V3DLONG i,j,k,c;
		V3DLONG pgsz1=sz[2]*sz[1]*sz[0], pgsz2=sz[1]*sz[0], pgsz3=sz[0];

		switch (tmpstack->kind)
		{
			case GREY:
			case COLOR:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_8(tmpstack,i,j,k,c);
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c);

				break;

			case GREY16:
				for (c=0;c<sz[3];c++)
					for (k=0;k<sz[2]; k++)
						for (j=0;j<sz[1]; j++)
							for (i=0;i<sz[0]; i++)
								//img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = STACK_PIXEL_16(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
								img[c*pgsz1 + k*pgsz2 + j*pgsz3 + i] = Get_Stack_Pixel(tmpstack,i,j,k,c)>>4; //assume it is 12-bit
				break;

			default:
				printf("The type of tif file is not supported in this version.\n");
				if (sz) {delete sz; sz=0;}
					if (img) {delete img; img=0;}
					Kill_Stack(tmpstack); tmpstack=0;
				b_error=1;
				return b_error;
				break;
		}
	}


	// kill stack
	if (tmpstack)
	{
		Kill_Stack(tmpstack);
		tmpstack=0;
	}

	return b_error;

}


//070806 - LSM file reading

int read_lsm_slice(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	if (TIFFIsTiled(in))
		return (read_lsm_slice_tile(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
	else
		return (read_lsm_slice_strip(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
}



int read_lsm_slice_strip(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize  = TIFFStripSize(in);
	if ((pagepixelnumber*datatype)!=bufsize)
	{
		fprintf(stderr, "The current strip has a different size from the expected size in read_lsm_slice_strip(). No data is read.\n");
		return 1;
	}

	//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);

	/*
    uint8 * row = image->array;
	V3DLONG width  = image->width;
	V3DLONG height = image->height;
	V3DLONG totalpixel=width*height;
	*/

	//if (buf) {
	if (pointer_first_page) {
		tstrip_t s, ns = TIFFNumberOfStrips(in);
		uint32 *bytecounts;
		uint32 *stripoffsets;

		TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);

		TIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);

		for (s = 0; s < ns; s++)
		{
			//printf("TIFFTAG_STRIPBYTECOUNTS and TIFFTAG_STRIPOFFSETS are [%d][%ld][%ld]\n", s, bytecounts[s], stripoffsets[s]);
			//if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, (tsize_t) -1)<0)

			//if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber)<0) //*datatype, 080301
			if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber*datatype, pagepixelnumber*datatype)<0) //*datatype, 080301 to handle 12/16 bit LSM
			//if (phc_TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber)<0)
			{
//				_TIFFfree(buf);
				//return (0);
				//(*in->tif_postdecode)(in, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber);
				continue;
			}
/*			else
			{
				unsigned char * curpt = ;
				V3DLONG i;
				for (i=0;i<bufsize;i++)
				{
					*curpt++ = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806
				}
			}
			*/
		}
		//_TIFFfree(buf);
		return (1);
	}
	return 0;
}


int read_lsm_slice_tile(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize = TIFFTileSize(in);
	if ((pagepixelnumber*datatype)!=bufsize)
	{
		fprintf(stderr, "The current tile has a different size from the expected size in read_lsm_slice_tile(). No data is read.\n");
		return 1;
	}

	//unsigned char *buf = (unsigned char *)_TIFFmalloc(bufsize);

	//if (buf) {
	if (pointer_first_page) {
		ttile_t t, nt = TIFFNumberOfTiles(in);
		uint32 *bytecounts;

		TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
		for (t = 0; t < nt; t++)
		{
			//if (TIFFReadEncodedTile(in, t, buf, bytecounts[t]) < 0)
			if (TIFFReadEncodedTile(in, t, pointer_first_page + V3DLONG(t)*channelpixelnumber, bytecounts[t]) < 0)
			{
//				_TIFFfree(buf);
				return (0);
			}
			/*
			else
			{
				V3DLONG i;
				for (i=0;i<bufsize;i++)
				{
					row[i*3+s] = (uint8)(buf[i]); //force the conversion. no work for 12-bit lsm yet. PHC 070806
				}
			}
			*/
		}
		//_TIFFfree(buf);
		return (1);
	}
	return 0;
}

int loadLsm2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	printf("enter V3D's loadLsm2Stack() function...\n");
	
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Open_TIFF function failed.\n");
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");
    if (!tif) return 1;
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	printf("# bits=%d\n", int(bits));

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = depth;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(depth);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);
		
		//printf("d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
			read_lsm_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype), pixel_per_slice, pixel_per_channel, datatype);
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* skip the one we just read, it's a thumbnail  */
			if (!TIFFReadDirectory(tif)) break;	  /* get the next slice  */
		}
	}

	TIFFClose(tif);

	//return (stack);
	return berror;
}


int loadLsmThumbnail2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsmThumbnail2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");
    if (!tif) return 1;

	TIFFReadDirectory(tif); //get to the first thumbnail image
//
	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = depth;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(depth);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		//printf("d=%ld, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!",d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
			read_lsm_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype), pixel_per_slice, pixel_per_channel, datatype);
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* skip the one we just read, it's a normal frame  */
			if (!TIFFReadDirectory(tif)) break;	  /* get the next thumbnail image  */
		}
	}

	TIFFClose(tif);

	return berror;
}

int loadLsmThumbnail2Stack_middle(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsmThumbnail2Stack_middle(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");
    if (!tif) return 1;

	TIFFReadDirectory(tif); //bypass a big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails )

	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<=int(depth/2);d++)
	{
		if (d<int(depth/2))
		{
			TIFFReadDirectory(tif); //bypass a thumbnail
			TIFFReadDirectory(tif); //bypass a big image
			continue;
		}

		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
		    //note that as we onlky read one slice here, the "img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype)" equals "img"
			read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
		}

		break; //after we read one slice, then stop;
	}

	TIFFClose(tif);

	return berror;
}

int loadLsm2Stack_middle(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	int berror=0;

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsm2Stack_middle(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */

	tif = Open_Tiff(filename,"r");
    if (!tif) return 1;

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Stack(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(width)*V3DLONG(height);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails )

	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<=int(depth/2);d++)
	{
		if (d<int(depth/2))
		{
			TIFFReadDirectory(tif); //bypass a big image
			TIFFReadDirectory(tif); //bypass a thumbnail
			continue;
		}

		TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
		TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
		TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
		TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

		printf("d=%ld, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

		if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
		{
			fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
			//in this case, do nothing to read the data and leave it empty
		}
		else
		{
		    //note that as we onlky read one slice here, the "img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype)" equals "img"
			read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
		}

		break; //after we read one slice, then stop;
	}

	TIFFClose(tif);

	return berror;
}


int loadLsmSlice(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail)
{
	int berror=0;

	if (sliceno<-2)
	{
		fprintf(stderr, "The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\n");
		return 1; //070805, by Hanchuan Peng
	}

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified LSM file in loadLsmSlice(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("%d\n", depth/2);
	//printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	depth = depth / 2;		/* half the dirs are thumbnails */
	if (sliceno>depth-1) sliceno=depth-1;
	//printf("slice #=%d\n", sliceno);

	tif = Open_Tiff(filename,"r");
    if (!tif) return 1;

	if (b_thumbnail)
		TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "LSM file should not support more than 16 bits data. Check the codes in loadLsm2Slice(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = (sliceno==-2) ? depth : 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(sz[1])*V3DLONG(sz[0]);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
    bool b_readnow=false;
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		if (sliceno>-2)
		{
			if (sliceno==-1) //middle slice only
			{
				b_readnow=(d==int(depth/2))?true:false;
			}
			else
			{
				b_readnow=(d==sliceno)?true:false;
			}
		}
		else
		{
			b_readnow=true;
		}

		if (b_readnow)
		{
			TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
			TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
			TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
			TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

			//printf("d=%d, current width=%d, height=%d, cur_colorchannels=%d, cur_bits=%d\n", d, cur_width, cur_height, cur_colorchannels, cur_bits); fflush(stdout); //080301

			if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
			{
				fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
				//in this case, do nothing to read the data and leave it empty
			}
			else
			{
				if (sliceno==-2)
				{
					read_lsm_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype), pixel_per_slice, pixel_per_channel, datatype);
				}
				else
				{
					read_lsm_slice(tif, img, pixel_per_slice, pixel_per_channel, datatype);
					break; //because only 1 read is needed in this case
				}
			}
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* one directory  */
			if (!TIFFReadDirectory(tif)) break;	  /* another directory */
		}
	}

	TIFFClose(tif);

	return berror;
}

//The following 3 functions are added on 2008-02-13
int loadTifSlice(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail)
{
	int berror=0;

	if (sliceno<-2)
	{
		fprintf(stderr, "The sliceno parameter is invalid. Must not <-2: -2 to read all slices, -1 to read middle only, 0 to N-1 to read the 1 to N-1 slice. If bigger than N-1, then just read the last slice.\n");
		return 1;
	}

	TIFF  *tif=0;
	int depth, width, height;
	short bits, colorchannels;

	tif = Open_Tiff(filename,"r");
	if (!tif)
	{
		fprintf(stderr, "Cannot open the specified TIFF file in loadTifSlice(). \n");
		return 1;
	}

	depth = 1;
	while (TIFFReadDirectory(tif))
		depth += 1;
	TIFFClose(tif);

	printf("%d\n", depth); //note that this sentence will be output an important info to use the pop_thumbnail php program
	//printf("Total # of directories is %d, half of them are thumbnails So real data have %d slices.\n", depth, depth/2);
	//depth = depth / 2;		/* half the dirs are thumbnails */
	if (sliceno>depth-1) sliceno=depth-1;
	//printf("slice #=%d\n", sliceno);

	tif = Open_Tiff(filename,"r");
    if (!tif) return 1;

	//if (b_thumbnail) TIFFReadDirectory(tif); //by pass one big image and get to the first thumbnail image

	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &width);
	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &height);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &colorchannels);
	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);

	if (bits<=8 && bits>0) datatype=1;
	else if (bits<=16 && bits>0) datatype=2;
	else
	{
		fprintf(stderr, "TIF file should not support more than 16 bits data. Check the codes in loadTifSlice(). \n");
		return 1; //070805, by Hanchuan Peng
	}

	V3DLONG pixel_per_slice, pixel_per_channel, ntotalpixel;
	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		fprintf(stderr,"Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	else
	{
		sz[0] = width;
		sz[1] = height;
		sz[2] = (sliceno==-2) ? depth : 1;
		sz[3] = colorchannels;
		pixel_per_slice = V3DLONG(sz[1])*V3DLONG(sz[0]);
		pixel_per_channel = pixel_per_slice*V3DLONG(sz[2]);
		ntotalpixel = pixel_per_channel*colorchannels;
	}

	if (img) {delete []img; img=0;}
	else
	{
		img = new unsigned char [V3DLONG(ntotalpixel)*V3DLONG(datatype)];
		if (!img)
		{
			fprintf(stderr,"Fail to allocate memory.\n");
			if (sz) {delete []sz;sz=0;}
			berror = 1;
			return berror;
		}
	}

	// read every other directory (real data, the in between are thumbnails
    bool b_readnow=false;
	V3DLONG d;
	short cur_colorchannels, cur_bits;
	int cur_width, cur_height;
	for (d=0;d<depth;d++)
	{
		if (sliceno>-2)
		{
			if (sliceno==-1) //middle slice only
			{
				b_readnow=(d==int(depth/2))?true:false;
			}
			else
			{
				b_readnow=(d==sliceno)?true:false;
			}
		}
		else
		{
			b_readnow=true;
		}

		if (b_readnow)
		{
			TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &cur_width);
			TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &cur_height);
			TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &cur_colorchannels);
			TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &cur_bits);

			//printf("d=%d, current width=%d, height=%d\n", d, cur_width, cur_height); fflush(stdout);

			if (cur_width != width || cur_height != height || cur_colorchannels!=colorchannels || cur_bits!=bits)
			{
				fprintf(stderr, "The %ld Individual image slice has a different size/colorchannel/bits from the first slice!", d);
				//in this case, do nothing to read the data and leave it empty
			}
			else
			{
				if (sliceno==-2)
				{
					read_tif_slice(tif, img+V3DLONG(d)*V3DLONG(pixel_per_slice)*V3DLONG(datatype)*sz[3], width, height);
					//printf("Read No. %d slice.\n", d);
				}
				else
				{
					read_tif_slice(tif, img, width, height);
					//printf("width=[%d] height=[%d] color=[%d] bits-per-sample=[%d].\n", width, height, cur_colorchannels, cur_bits);
					//printf("Read No. %d slice.\n", d);
					//read_directory(tif,Select_Plane(stack,d),"Read_Stack");
					break; //because only 1 read is needed in this case
				}
			}
		}

		if (d==depth-1)
			break; //no need to do read directory anymore once the last one is read
		else
		{
			if (!TIFFReadDirectory(tif)) break;	  /* one directory  */
			//if (!TIFFReadDirectory(tif)) break;	  /* another directory */
		}
	}

	TIFFClose(tif);

	//debugging code: verification succeeds in Matlab reading code:
	//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*3, 'uint8');a=reshape(a,[3 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)

	//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
	//fwrite(img, 3, width*height,tmp_fp);
	//fclose(tmp_fp);


	//produce thumbnail if required
	if (b_thumbnail)
	{
		V3DLONG thumbsz0=128, thumbsz1=128;
		if (sz[0]>thumbsz0 || sz[1]>thumbsz1)
		{
			unsigned char * img1 = new unsigned char [V3DLONG(thumbsz0)*thumbsz1*sz[2]*sz[3]*V3DLONG(datatype)];
			unsigned char ****img4d1 = 0;
			new4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2], img1);

			unsigned char ****img4d = 0;
			new4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img);

			double factor_jj=sz[1]/thumbsz1, factor_ii=sz[0]/thumbsz0;
			for (V3DLONG kk=0;kk<sz[2];kk++)
			{
				for (V3DLONG jj=0; jj<thumbsz1; jj++)
				{
					for (V3DLONG ii=0;ii<thumbsz0; ii++)
					{
						for (V3DLONG cc=0;cc<sz[3];cc++)
						{
							img4d1[kk][jj][ii][cc] = img4d[kk][V3DLONG(floor(jj*factor_jj))][V3DLONG(floor(ii*factor_ii))][cc];
						}
					}
				}
			}

			delete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);
			delete4dpointer(img4d1, sz[3], thumbsz0, thumbsz1, sz[2]);

			delete []img;
			img = img1;
			sz[0] = thumbsz0;
			sz[1] = thumbsz1;
			//sz[2] and sz[3] do not need change
		}
	}

	//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
	//fwrite(img, 3, width*height,tmp_fp);
	//fclose(tmp_fp);

	//permute the data to make sure it will be output correctly
	unsigned char ****img4d = 0;
	new4dpointer(img4d, sz[3], sz[0], sz[1], sz[2], img); //must realize this order!

	unsigned char * img1 = new unsigned char [sz[0]*sz[1]*sz[2]*sz[3]];
	unsigned char ****img4d1 = 0;
	new4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3], img1);

	for (V3DLONG tcc=0;tcc<sz[3];tcc++)
	{
		for (V3DLONG tkk=0;tkk<sz[2];tkk++)
		{
			for (V3DLONG tjj=0;tjj<sz[1];tjj++)
			{
				for (V3DLONG tii=0;tii<sz[0];tii++)
				{
					img4d1[tcc][tkk][tjj][tii] = img4d[tkk][tjj][tii][tcc];
				}
			}
		}
	}

	delete4dpointer(img4d1, sz[0], sz[1], sz[2], sz[3]);
	delete4dpointer(img4d, sz[3], sz[0], sz[1], sz[2]);
	if (img) {delete []img; img=0;}
	img = img1;

	return berror;
}

int read_tif_slice(TIFF *tif, unsigned char * pointer_first_page, V3DLONG width, V3DLONG height)
//note that this is not a general tif slice reader, - but should work for date generated using Gene's code
{
	//	if (TIFFIsTiled(in))
	//		return (read_tif_slice_tile(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));
	//	else
	//		return (read_tif_slice_strip(in, pointer_first_page, pagepixelnumber, channelpixelnumber, datatype));

	//

	//first determine the image type

	enum PImagePixelType {PTIF_GREY, PTIF_GREY16, PTIF_COLOR};
	PImagePixelType pixelType;


	short bits, channels, photo;

	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &bits);
	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &channels);
	TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &photo);
	if (photo <= 1)
    {
		if (channels > 1)
			fprintf(stderr, "Black and white tiff has more than 1 channel!");
		if (bits == 16)
			pixelType = PTIF_GREY16;
		else
			pixelType = PTIF_GREY;
    }
	else
		pixelType = PTIF_COLOR;

	// then read data

	uint32 *raster = new uint32 [width*height];
	if (!raster)
	{
		fprintf(stderr, "Fail to allocate memory in read_tif_slice();\n");
		return 1;
	}

	unsigned char  *row;

	row = pointer_first_page;

	if (pixelType != PTIF_GREY16)
    {
		int i, j;
		uint32 *in;
		uint8  *out;

		if (TIFFReadRGBAImage(tif,width,height,raster,0) == 0)
		{
			fprintf(stderr, "read of tif failed in read_tif_slice()");
			if (raster) {delete []raster; raster=0;}
			return 1;
		}

		//debugging code: verification succeeds in Matlab reading code:
		//t=fopen('/Users/pengh/Desktop/temp/test1.dat');a=fread(t, 512*512*4, 'uint8');a=reshape(a,[4 512 512]);a=permute(a, [2 3 1]);fclose(t); imshow(a(:,:,1:3)/255)

		//FILE * tmp_fp=fopen("/Users/pengh/temp/test1.dat", "w");
		//fwrite(raster, 4, width*height,tmp_fp);
		//fclose(tmp_fp);

		in = raster;
		if (pixelType == PTIF_GREY)
        {
			for (j = height-1; j >= 0; j--)
			{
				out = row;
				for (i = 0; i < width; i++)
				{
					uint32 pixel = *in++;
					*out++ = TIFFGetR(pixel);
				}
				row += width;
			}
        }
		else
        {
			for (j = height-1; j >= 0; j--)
			{
				out = row;
				for (i = 0; i < width; i++)
				{
					uint32 pixel = *in++;
					*out++ = TIFFGetR(pixel);
					*out++ = TIFFGetG(pixel);
					*out++ = TIFFGetB(pixel);
				}
				row += width*3;
			}
        }
    }

	else

    {
		int tile_width, tile_height;

		if (TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tile_width))    // File is tiled
        { int x, y;
			int i, j;
			int m, n;
			uint16 *buffer = (uint16 *) raster;
			uint16 *out, *in; //, *rous;

			TIFFGetField(tif, TIFFTAG_TILELENGTH, &tile_height);

			for (y = 0; y < height; y += tile_height)
            { if (y + tile_height > height)
                n = height - y;
				else
					n = tile_height;
				for (x = 0; x < width; x += tile_width)
                { TIFFReadTile(tif, buffer, x, y, 0, 0);
					if (x + tile_width > width)
						m = width - x;
					else
						m = tile_width;
					for (j = 0; j < n; j++)
                    { out = (uint16 *) (row + 2*(j*width + x));
						in  = buffer + j*tile_width;
						for (i = 0; i < m; i++)
							*out++ = *in++;
                    }
                }
				row += n*width*2;
            }
        }

		else    // File is striped

        { int     y;

			for (y = 0; y < height; y++)
            { TIFFReadScanline(tif, row, y, 0);
				row += width*2;
            }
        }
    }

	if (raster) {delete []raster; raster=0;}
	//
	return 0;
	//

}



int read_tif_slice_strip(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize  = TIFFStripSize(in);
	if (pagepixelnumber!=bufsize)
	{
		fprintf(stderr, "The current strip has a different size [%ld] from the expected size [%ld] in read_tif_slice_strip(). No data is read.\n", V3DLONG(bufsize), pagepixelnumber);
		return 1;
	}

	if (pointer_first_page) {
		tstrip_t s, ns = TIFFNumberOfStrips(in);
		uint32 *bytecounts;
		uint32 *stripoffsets;

		TIFFGetField(in, TIFFTAG_STRIPBYTECOUNTS, &bytecounts);

		TIFFGetField(in, TIFFTAG_STRIPOFFSETS, &stripoffsets);

		for (s = 0; s < ns; s++)
		{
			if (TIFFReadEncodedStrip(in, s, pointer_first_page + V3DLONG(s)*channelpixelnumber, pagepixelnumber)<0)
			{
				continue;
			}
		}
		return (1);
	}
	return 0;
}


int read_tif_slice_tile(TIFF *in, unsigned char * pointer_first_page, V3DLONG pagepixelnumber, V3DLONG channelpixelnumber, int datatype)
{
	tsize_t bufsize = TIFFTileSize(in);
	if (pagepixelnumber!=bufsize)
	{
		fprintf(stderr, "The current tile has a different size from the expected size in read_tif_slice_tile(). No data is read.\n");
		return 1;
	}

	if (pointer_first_page) {
		ttile_t t, nt = TIFFNumberOfTiles(in);
		uint32 *bytecounts;

		TIFFGetField(in, TIFFTAG_TILEBYTECOUNTS, &bytecounts);
		for (t = 0; t < nt; t++)
		{
			if (TIFFReadEncodedTile(in, t, pointer_first_page + V3DLONG(t)*channelpixelnumber, bytecounts[t]) < 0)
			{
				return (0);
			}
		}
		return (1);
	}
	return 0;
}


int loadRawSlice(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}

int loadRawSlice_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}


int loadMRC2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) // MRC reading
{
	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	//read header
	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 3, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=3)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	mysz[3]=1; //now set #ch = 1

	V3DLONG dcode = 0;
	fread(&dcode, 4, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */

	switch (dcode)
	{
		case 0: //signed 8bit
			datatype = 1;
			break;

		case 1: //signed 16bit
		case 6: //unsigned 16-bit
			datatype = 2;
			break;

		case 2: //float
			datatype = 4;
			break;

		default:
                        printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", (int)dcode);
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	fseek(fid,1024,SEEK_SET);

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	V3DLONG i, nread;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	if ((totalUnit*unitSize+1024) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+1024);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

//	/* swap the data bytes if necessary */
//
//	if (b_swap==1)
//	{
//		if (unitSize==2)
//		{
//			for (i=0;i<totalUnit; i++)
//			{
//				swap2bytes((void *)(img+i*unitSize));
//			}
//		}
//		else if (unitSize==4)
//		{
//			for (i=0;i<totalUnit; i++)
//			{
//				swap4bytes((void *)(img+i*unitSize));
//			}
//		}
//	}

	/* clean and return */

	fclose(fid);

	return berror;
}

int saveStack2MRC(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype) // MRC writing
{
	int berror=0;
	return berror;
}


//070214: add a simple interface to read and save all supported file formats

bool ensure_file_exists_and_size_not_too_big(char *filename, V3DLONG sz_thres)
{
#ifdef ENVIRONMENT32

    FILE * fid = fopen(filename, "rb");
    if (!fid)
    {
        printf("The file [%s] does not exist or cannot be read.\n", filename);
        return false;
    }

    fseek (fid, 0, SEEK_END);
    V3DLONG fileSize = ftell(fid);
    rewind(fid);
    fclose(fid);

    if(fileSize>sz_thres)
    {
        printf("The file [%s] has a too big size [= %ld bytes ] > [%ld bytes] which is the limit of the loadImage function. Do nothing. \n", filename, fileSize, sz_thres);
        return false;
    }

    return true;

#else

    return true;

#endif
}



//

bool loadImage(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, int & datatype)
{
	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}

	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;
	bool b_5d=false;

    const char * curFileSuffix = getSuffix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);

//    if (curFileSuffix && (strcasecmp(curFileSuffix, "nrrd")==0)) //read nrrd stacks
//    {
//        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //tif file at most should be 900M bytes
//        {
//            printf("The tif file may not exist or may be too big to load.\n");
//            return false;
//        }
//        if (read_nrrd(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
//        {
//            printf("Error happens in NRRD file reading. Stop. \n");
//            return false;
//        }
//    }
    if (curFileSuffix && (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0)) //read tiff stacks
	{
        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //tif file at most should be 900M bytes
		{
            printf("The tif file may not exist or may be too big to load [sz threshold=%ld bytes].\n", (V3DLONG)1024*1024*ZZBIG);
			return false;
		}
		if (loadTif2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in TIF file reading. Stop. \n");
			return false;
		}
	}
#ifdef _ALLOW_WORKMODE_MENU_    
	else if (curFileSuffix && ImageLoaderBasic::hasPbdExtension(imgSrcFile) ) // read v3dpbd - pack-bit-difference encoding for sparse stacks
    {
		v3d_msg("prepare for pbd file loading", 0);
		Image4DSimple *tmpimg=new Image4DSimple;
		
	    ImageLoaderBasic imageLoader;
	    if (!imageLoader.loadImage(tmpimg, imgSrcFile)) {
	        printf("Error happens in v3dpbd file reading. Stop. \n");
	        return false;
	    }
	    // The following few lines are to avoid disturbing the existing code below
	    
	    tmp_data1d = tmpimg->getRawData();
	    tmp_datatype=tmpimg->getDatatype();
	    tmp_sz=new V3DLONG[4];
	    tmp_sz[0]=tmpimg->getXDim();
	    tmp_sz[1]=tmpimg->getYDim();
	    tmp_sz[2]=tmpimg->getZDim();
	    tmp_sz[3]=tmpimg->getCDim();
	}
#endif
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "lsm")==0 ) //read lsm stacks
	{
        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //2047 //lsm file at most should be 900M bytes
		{
            printf("The lsm file may not exist or may be too big to load [sz threshold=%ld bytes].\n", (V3DLONG)1024*1024*ZZBIG);
			return false;
		}
		if (loadLsm2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in LSM file reading. Stop. \n");
			return false;
		}
	}
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "mrc")==0 ) //read MRC stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //MRC file at most should be 1.5G bytes
		{
			printf("The MRC file may not exist or may be too big to load.\n");
			return false;
		}
        
		if (loadMRC2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct MRC file. \n");
			return false;
		}
	}
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "raw5")==0 ) //read lsm stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //
		{
			printf("The lsm file may not exist or may be too big to load [sz threshold=%ld bytes].\n", (V3DLONG)1024*1024*ZZBIG);
			return false;
		}
		if (loadRaw5d2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in V3D .raw5 (5D) file reading. Stop. \n");
			return false;
		}
		b_5d = true;
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
                if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
                {
                        printf("The RAW file may not exist or may be too big to load.\n");
                        return false;
                }

		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}
		}
	}


	//copy output data

	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
				if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
				if (sz) {delete []sz; sz=0;}
				return false;
	}

	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = (b_5d) ? tmp_sz[4] : 1; //090802

	data1d = tmp_data1d;
	
	/* clean all workspace variables */

	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}

	return true;
}

bool loadImage(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, int & datatype, int chan_id_to_load) //081204
{
	//printf("*** Warning: The overloaded function loadImage() with a specified channel only works for 4-byte RAW at this moment (as of 081204) ***. \n");
	if (chan_id_to_load<0)
	{
		printf("Warning: The specified chan_id_to_load is <0. \n");
		return false;
	}

	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}

	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;

    const char * curFileSuffix = getSuffix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);

    if (curFileSuffix && (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0)) //read tiff stacks
	{
        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //tif file at most should be 900M bytes
		{
			printf("The tif file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadTif2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
		{
			printf("Error happens in TIF file reading. Stop. \n");
			return false;
		}
	}
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "lsm")==0 ) //read lsm stacks
	{
        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //lsm file at most should be 900M bytes
		{
			printf("The lsm file may not exist or may be too big to load.\n");
			return false;
		}
		if (loadLsm2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
		{
			printf("Error happens in LSM file reading. Stop. \n");
			return false;
		}
	}
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "mrc")==0 ) //read MRC stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //MRC file at most should be 1.5G bytes
		{
			printf("The MRC file may not exist or may be too big to load.\n");
			return false;
		}

		if (loadMRC2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct MRC file. \n");
			return false;
		}
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
		{
			printf("The RAW file may not exist or may be too big to load.\n");
			return false;
		}

		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}
		}
	}

	//copy output data

	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
				if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
				if (sz) {delete []sz; sz=0;}
				return false;
	}

	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = 1; //just set the 5th dim as 1 for consistency of the other loadImage() function

	data1d = tmp_data1d;

	/* clean all workspace variables */

	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}

	return true;
}


bool saveImage(const char filename[], const unsigned char * data1d, const V3DLONG * sz, const int datatype)
{
	if (!data1d || !filename || !sz)
	{
		printf("This image data is empty or the file name or the size pointer is invalid. Nothing done.\n");
		return false;
	}

	int dt;
    ImagePixelType curtype;
	switch (datatype)
	{
        case 1:  dt=1; curtype = V3D_UINT8; break;
        case 2:  dt=2; curtype = V3D_UINT16; break;
        case 4:  dt=4; curtype = V3D_FLOAT32; break;
		default:
			printf("The data type is unsupported. Nothing done.\n");
			return false;
			break;
	}

    const char * curFileSuffix = getSuffix((char *)filename);
    if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
    
    //it seems when curFileSuffix is NULL then strcasecmp() has a crashing bug. thus check now. 20120410. by PHC
	if (curFileSuffix && (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0)) //write tiff stacks
	{
		if (saveStack2Tif(filename, data1d, sz, dt))
		{
			printf("Error happens in writing TIF file [%s]. Stop. \n", filename);
			return false;
		}
	}
	else if (curFileSuffix && strcasecmp(curFileSuffix, "raw5")==0) //write .raw5 data
	{
		if (saveStack2Raw5d(filename, data1d, sz, dt))
		{
			printf("Error happens in writing V3D .raw5 file [%s]. Stop. \n", filename);
			return false;
		}
	}
#ifdef _ALLOW_WORKMODE_MENU_
    else if (curFileSuffix &&  (strcasecmp(curFileSuffix, "v3dpbd")==0)) //  v3dpbd - pack-bit-difference encoding for sparse stacks
        // || strcasecmp(curFileSuffix, "mp4")==0) ) //to add mp4 later
    {
        v3d_msg("prepare for pbd file saving", 0);
        ImageLoaderBasic imageLoader;
        if (imageLoader.saveStack2RawPBD(filename, curtype, (unsigned char *)data1d, sz)) {
            printf("Error happens in v3dpbd file saving. Stop. \n");
            return false;
        }
    }
#endif
    else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
            printf("The data is not with a known Vaa3D format, -- now this program assumes it is a Vaa3D RAW format. \n");
		if (saveStack2Raw(filename, data1d, sz, dt)!=0) //0 is no error //note that as I updated the saveStack2Raw to RAW-4-byte, the actual mask file cannot be read by the old wano program, i.e. the wano must be updated on Windows machine as well. 060921
		{
			printf("Error happens in writing RAW file stack [defined by Hanchuan Peng] [%s].\n", filename);
			return false;
		}
	}

    return true;
}


#endif //__STACKUTIL_CPP__


