/*****************************************************************************************\
*                                                                                         *
*  Array Data Abstraction                                                                 *
*                                                                                         *
*  Author:  Gene Myers                                                                    *
*  Date  :  December 2008                                                                 *
*                                                                                         *
*  (c) July 27, '09, Dr. Gene Myers and Howard Hughes Medical Institute                   *
*      Copyrighted as per the full copy in the associated 'README' file                   *
*                                                                                         *
\*****************************************************************************************/
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <float.h>
#include <math.h>

#include "utilities.h"
#include "array.h"
#include "linear.algebra.h"




/****************************************************************************************
 *                                                                                      *
 *  ARRAY SIZE, SHAPE & TYPE COMPARISONS                                                *
 *                                                                                      *
 ****************************************************************************************/

static Size_Type array_size(Array *a)
{ Size_Type p;
  int       i;
  p = 1;
  for (i = 0; i < a->ndims; i++)
    p *= a->dims[i];
  return (p);
}

int Same_Shape(Array *a, Array *b)
{ int i;

  if (a->ndims != b->ndims)
    return (0);
  for (i = 0; i < a->ndims; i++)
    if (a->dims[i] != b->dims[i])
      return (0);
  return (1);
}

int Same_Type(Array *a, Array *b)
{ if (a->type != b->type)
    return (0);
  return (Same_Shape(a,b));
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY SPACE MANAGEMENT ROUTINES                                                     *
 *                                                                                      *
 ****************************************************************************************/

// Awk-generated (manager.awk) Array memory management

static int type_size[] = { 1, 2, 4, 8, 1, 2, 4, 8, 4, 8 };

static int bit_size[] = { 8, 16, 32, 64, 8, 16, 32, 64, 32, 64 };

static int kind_size[] = { 1, 3, 4, 2 };

static int dimn_type[] = { 0, UINT8, UINT16, 0, UINT32, 0, 0, 0, UINT64 };

static inline int array_nsize(Array *a)
{ return (sizeof(int)*a->ndims); }

static inline uint64 array_dsize(Array *a)
{ return (a->size*type_size[a->type]); }

static inline int array_tsize(Array *a)
{ return (a->tlen); }


typedef struct __Array
  { struct __Array *next;
    struct __Array *prev;
    int             refcnt;
    int             nsize;
    uint64          dsize;
    int             tsize;
    Array           array;
  } _Array;

static _Array *Free_Array_List = NULL;
static _Array *Use_Array_List  = NULL;
static _Array  Array_Proto;

static int Array_Offset = ((char *) &(Array_Proto.array)) - ((char *) &Array_Proto);
static int Array_Inuse  = 0;

int Array_Refcount(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->refcnt);
}

static inline void allocate_array_dims(Array *array, int nsize, char *routine)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  if (object->nsize < nsize)
    { array->dims = Guarded_Realloc(array->dims,nsize,routine);
      object->nsize = nsize;
    }
}

static inline int sizeof_array_dims(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->nsize);
}

static inline void allocate_array_data(Array *array, uint64 dsize, char *routine)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  if (object->dsize < dsize)
    { array->data = Guarded_Realloc(array->data,dsize,routine);
      object->dsize = dsize;
    }
}

static inline uint64 sizeof_array_data(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->dsize);
}

static inline void allocate_array_text(Array *array, int tsize, char *routine)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  if (object->tsize < tsize)
    { array->text = Guarded_Realloc(array->text,tsize,routine);
      object->tsize = tsize;
    }
}

static inline int sizeof_array_text(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->tsize);
}

static inline Array *new_array(int nsize, uint64 dsize, int tsize, char *routine)
{ _Array *object;
  Array  *array;

  if (Free_Array_List == NULL)
    { object = (_Array *) Guarded_Realloc(NULL,sizeof(_Array),routine);
      array = &(object->array);
      object->nsize = 0;
      array->dims = NULL;
      object->dsize = 0;
      array->data = NULL;
      object->tsize = 0;
      array->text = NULL;
    }
  else
    { object = Free_Array_List;
      Free_Array_List = object->next;
      array = &(object->array);
    }
  Array_Inuse += 1;
  object->refcnt = 1;
  if (Use_Array_List != NULL)
    Use_Array_List->prev = object;
  object->next = Use_Array_List;
  object->prev = NULL;
  Use_Array_List = object;
  allocate_array_dims(array,nsize,routine);
  allocate_array_data(array,dsize,routine);
  allocate_array_text(array,tsize,routine);
  return (array);
}

static inline Array *copy_array(Array *array)
{ Array *copy = new_array(array_nsize(array),array_dsize(array),array_tsize(array),"Copy_Array");
  void *_dims = copy->dims;
  void *_data = copy->data;
  void *_text = copy->text;
  *copy = *array;
  copy->dims = _dims;
  if (array->dims != NULL)
    memcpy(copy->dims,array->dims,array_nsize(array));
  copy->data = _data;
  if (array->data != NULL)
    memcpy(copy->data,array->data,array_dsize(array));
  copy->text = _text;
  if (array->text != NULL)
    memcpy(copy->text,array->text,array_tsize(array));
  return (copy);
}

Array *Copy_Array(Array *array)
{ return ((Array *) copy_array(array)); }

static inline void pack_array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  if (object->nsize > array_nsize(array))
    { object->nsize = array_nsize(array);
      if (object->nsize != 0)
        array->dims = Guarded_Realloc(array->dims,
                                      object->nsize,"Pack_Array");
      else
        { free(array->dims);
          array->dims = NULL;
        }
    }
  if (object->dsize > array_dsize(array))
    { object->dsize = array_dsize(array);
      if (object->dsize != 0)
        array->data = Guarded_Realloc(array->data,
                                      object->dsize,"Pack_Array");
      else
        { free(array->data);
          array->data = NULL;
        }
    }
  if (object->tsize > array_tsize(array))
    { object->tsize = array_tsize(array);
      if (object->tsize != 0)
        array->text = Guarded_Realloc(array->text,
                                      object->tsize,"Pack_Array");
      else
        { free(array->text);
          array->text = NULL;
        }
    }
}

Array *Pack_Array(Array *array)
{ pack_array(array);
  return (array);
}

Array *Inc_Array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  object->refcnt += 1;
  return (array);
}

static inline void free_array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  if (--object->refcnt > 0) return;
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Freeing previously released Array\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Array_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  object->next = Free_Array_List;
  Free_Array_List = object;
  Array_Inuse -= 1;
}

void Free_Array(Array *array)
{ free_array(array); }

static inline void kill_array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  if (--object->refcnt > 0) return;
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Killing previously released Array\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Array_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  if (object->tsize != 0)
    free(array->text);
  if (object->dsize != 0)
    free(array->data);
  if (object->nsize != 0)
    free(array->dims);
  free(((char *) array) - Array_Offset);
  Array_Inuse -= 1;
}

void Kill_Array(Array *array)
{ kill_array(array); }

static inline void reset_array()
{ _Array *object;
  Array  *array;
  while (Free_Array_List != NULL)
    { object = Free_Array_List;
      Free_Array_List = object->next;
      array = &(object->array);
      if (object->tsize != 0)
        free(array->text);
      if (object->dsize != 0)
        free(array->data);
      if (object->nsize != 0)
        free(array->dims);
      free(object);
    }
}

void Reset_Array()
{ reset_array(); }

int Array_Usage()
{ return (Array_Inuse); }

void Array_List(void (*handler)(Array *))
{ _Array *a, *b;
  for (a = Use_Array_List; a != NULL; a = b)
    { b = a->next;
      handler((Array *) &(a->array));
    }
}

static inline Array *read_array(FILE *input)
{ char name[5];
  fread(name,5,1,input);
  if (strncmp(name,"Array",5) != 0)
    return (NULL);
  Array *obj = new_array(0,0,0,"Read_Array");
  fread(obj,sizeof(Array),1,input);
  obj->dims = NULL;
  if (array_nsize(obj) != 0)
    { allocate_array_dims(obj,array_nsize(obj),"Read_Array");
      fread(obj->dims,array_nsize(obj),1,input);
    }
  obj->data = NULL;
  if (array_dsize(obj) != 0)
    { allocate_array_data(obj,array_dsize(obj),"Read_Array");
      fread(obj->data,array_dsize(obj),1,input);
    }
  obj->text = NULL;
  if (array_tsize(obj) != 0)
    { allocate_array_text(obj,array_tsize(obj),"Read_Array");
      fread(obj->text,array_tsize(obj),1,input);
    }
  return (obj);
}

Array *Read_Array(FILE *input)
{ return ((Array *) read_array(input)); }

static inline void write_array(Array *array, FILE *output)
{ fwrite("Array",5,1,output);
  fwrite(array,sizeof(Array),1,output);
  if (array_nsize(array) != 0)
    fwrite(array->dims,array_nsize(array),1,output);
  if (array_dsize(array) != 0)
    fwrite(array->data,array_dsize(array),1,output);
  if (array_tsize(array) != 0)
    fwrite(array->text,array_tsize(array),1,output);
}

void Write_Array(Array *array, FILE *output)
{ write_array(array,output); }


/****************************************************************************************
 *                                                                                      *
 *  MAKE AN ARRAY                                                                       *
 *                                                                                      *
 ****************************************************************************************/

static Array *make_start(Array_Kind kind, Array_Type type, int ndims, char *routine)
{ Array  *a;

  a = new_array(sizeof(int)*ndims,0,1,routine);
  a->type    = type;
  a->kind    = kind;
  a->scale   = bit_size[type];
  a->text[0] = '\0';
  a->tlen    = 1;
  a->ndims   = ndims;
  return (a);
}

static Array *make_shape(Array_Kind kind, Array_Type type, int ndims, Dimn_Type *dims,
                         char *routine)
{ Array *a;
  int    i, o, v;

  o = (kind != PLAIN_KIND);
  v = (kind == COMPLEX_KIND);
  a = make_start(kind,type,ndims+o,routine);
  if (v)
    a->dims[0] = kind_size[kind];
  for (i = 0; i < ndims; i++)
    a->dims[i+v] = dims[i];
  if (o & !v)
    a->dims[ndims] = kind_size[kind];
  a->size = array_size(a);
  return (a);
}

Array *G(Make_Array)(Array_Kind kind, Array_Type type, int ndims, Dimn_Type *dims)
{ Array *a;

  a = make_shape(kind,type,ndims,dims,"Make_Array");

  allocate_array_data(a,array_dsize(a),"Make_Array");

  return (a);
}

Array *G(Make_Array_With_Shape)(Array_Kind kind, Array_Type type, Coordinate *F(shape))
{ Array *a;

  a = make_shape(kind,type,shape->dims[0],ADIMN(shape),"Make_Array_With_Shape");

  allocate_array_data(a,array_dsize(a),"Make_Array_With_Shape");

  Free_Array(shape);

  return (a);
}

Array *G(Make_Array_Of_Data)(Array_Kind kind, Array_Type type, int ndims, Dimn_Type *dims,
                             void *data)
{ Array *a;

  a = make_shape(kind,type,ndims,dims,"Make_Array_Of_Data");

  { _Array *object = (_Array *) (((char *) a) - Array_Offset);
    if (object->dsize > 0)
      free(a->data);
    object->dsize  = array_dsize(a);
    a->data = data;
  }

  return (a);
}

Array *G(Make_Array_From_Arrays)(Array_Kind kind, int n, Array **arrays)
{ Array    *a, *a0;
  int       i, ndims;
  Size_Type dsize;

  a0 = arrays[0];
  if (n > 1)
    { for (i = 1; i < n; i++)
        if ( ! Same_Type(arrays[i],a0))
          { fprintf(stderr,
               "Arrays are not all of the same type and shape (Make_Array_From_Arrays)\n");
            exit (1);
          }
    }
  if (kind == COMPLEX_KIND && a0->ndims > 0)
    { for (i = 0; i < n; i++)
        if (arrays[i]->kind != COMPLEX_KIND)
          { fprintf(stderr,"Arrays must all be COMPLEX (Make_Array_From_Arrays)\n");
            exit (1);
          }
    }
  else
    { for (i = 0; i < n; i++)
        if (arrays[i]->kind != PLAIN_KIND)
          { fprintf(stderr,"Arrays must all be PLAIN (Make_Array_From_Arrays)\n");
            exit (1);
          }
    }
  if (kind != PLAIN_KIND && (kind != COMPLEX_KIND || a0->ndims == 0) && n != kind_size[kind])
    { fprintf(stderr,"Outer dimension and kind are not consistent (Make_Array_From_Arrays)\n");
      exit (1);
    }

  dsize = array_dsize(arrays[0]);
  ndims = a0->ndims;

  a = new_array(sizeof(int)*(ndims+1),n*dsize,1,"Make_Array_From_Arrays");

  a->type    = a0->type;
  a->kind    = kind;
  a->scale   = a0->scale;
  a->tlen    = 1;
  a->text[0] = '\0';
  a->ndims   = ndims+1;
  for (i = 0; i < ndims; i++)
    a->dims[i] = a0->dims[i];
  a->dims[ndims] = n;
  a->size        = n * a0->size;

  for (i = 0; i < n; i++)
    memcpy(a->data + i*dsize, arrays[i]->data, dsize);

  return (a);
}


/****************************************************************************************
 *                                                                                      *
 *  COORDS, GET & SET                                                                   *
 *                                                                                      *
 ****************************************************************************************/

static Dimn_Type  Coord_Ndim, Coord_Max = 0;
static Dimn_Type *Coord_Dims;

void Set_Coord_Basis(Coordinate *F(point))
{ if (point == NULL)
    { Coord_Dims = NULL;
      Coord_Ndim = 0;
      return;
    }
  if (point->ndims != 1 || point->type != dimn_type[sizeof(Dimn_Type)])
    { fprintf(stderr,"Coordinate is not an integer vector (Set_Coord_Basis)\n");
      exit (1);
    }
  if (point->dims[0] > Coord_Max)
    { Coord_Max = point->dims[0] + 10;
      Coord_Dims = Guarded_Realloc(Coord_Dims,sizeof(Dimn_Type)*Coord_Max,"Set_Coord_Basis");
    }
  Coord_Ndim = point->dims[0];
  memcpy(Coord_Dims,ADIMN(point),sizeof(Dimn_Type)*Coord_Ndim);
  Free_Array(point);
}

Coordinate *G(Get_Coord_Basis)()
{ Dimn_Type  dim[1];
  Array     *point;

  if (Coord_Dims == NULL)
    return (NULL);
  dim[0] = Coord_Ndim;
  point  = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dim);
  memcpy(ADIMN(point),Coord_Dims,sizeof(Dimn_Type)*Coord_Ndim);
  return (point);
}

void Use_Array_Basis(Array *a)
{ if (a->ndims > Coord_Max)
    { Coord_Max = a->ndims + 10;
      Coord_Dims = Guarded_Realloc(Coord_Dims,sizeof(Dimn_Type)*Coord_Max,"Use_Array_Basis");
    }
  Coord_Ndim = a->ndims;
  memcpy(Coord_Dims,a->dims,sizeof(Dimn_Type)*Coord_Ndim);
}

Coordinate *G(Coord)(char *list)
{ Array     *coord;
  Dimn_Type  dim[1], *c;
  int        i, n;
  char      *b, *e;

  n = 1;
  for (i = 0; i < strlen(list); i++)
    if (list[i] == ',')
      n += 1;

  dim[0] = n;
  coord  = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dim);

  c = ADIMN(coord);
  b = list;
  while (1)
    { c[--n] = strtol(b,&e,10);
      if (b == e)
        { fprintf(stderr,"Not a valid constant coordinate list (Coord)\n");
          exit (1);
        }
      b = e;
      if (*b == '\0')
        break;
      if (*b++ != ',')
        { fprintf(stderr,"Not a valid constant coordinate list (Coord)\n");
          exit (1);
        }
    }

  return (coord);
}

char *Coord_String(Coordinate *point)
{ static int   Buffer_Max = 0;
  static char *Buffer_Ret = NULL;

  char buffer[100];
  int  i, len;

  int        n = point->dims[0];
  Dimn_Type *d = ADIMN(point);

  switch (point->type) {
      case UINT8:
        len = snprintf(buffer,1,"%u",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%u",d[i]);
        break;
      case UINT16:
        len = snprintf(buffer,1,"%u",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%u",d[i]);
        break;
      case UINT32:
        len = snprintf(buffer,1,"%u",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%u",d[i]);
        break;
      case UINT64:
        len = snprintf(buffer,1,"%llu",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%llu",d[i]);
        break;
      case INT8:
        len = snprintf(buffer,1,"%d",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%d",d[i]);
        break;
      case INT16:
        len = snprintf(buffer,1,"%d",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%d",d[i]);
        break;
      case INT32:
        len = snprintf(buffer,1,"%d",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%d",d[i]);
        break;
      case INT64:
        len = snprintf(buffer,1,"%lld",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%lld",d[i]);
        break;
      case FLOAT32:
        len = snprintf(buffer,1,"%g",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%g",d[i]);
        break;
      case FLOAT64:
        len = snprintf(buffer,1,"%g",d[0]);
        for (i = 1; i < n; i++)
          len += snprintf(buffer,1,",%g",d[i]);
        break;
  }

  if (len > Buffer_Max)
    { Buffer_Max = 1.1*len + 30;
      Buffer_Ret = (char *) Guarded_Realloc(Buffer_Ret,Buffer_Max+1,"Coord_String");
    }

  switch (point->type) {
      case UINT8:
        len = sprintf(Buffer_Ret,"%u",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%u",d[i]);
        break;
      case UINT16:
        len = sprintf(Buffer_Ret,"%u",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%u",d[i]);
        break;
      case UINT32:
        len = sprintf(Buffer_Ret,"%u",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%u",d[i]);
        break;
      case UINT64:
        len = sprintf(Buffer_Ret,"%llu",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%llu",d[i]);
        break;
      case INT8:
        len = sprintf(Buffer_Ret,"%d",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%d",d[i]);
        break;
      case INT16:
        len = sprintf(Buffer_Ret,"%d",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%d",d[i]);
        break;
      case INT32:
        len = sprintf(Buffer_Ret,"%d",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%d",d[i]);
        break;
      case INT64:
        len = sprintf(Buffer_Ret,"%lld",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%lld",d[i]);
        break;
      case FLOAT32:
        len = sprintf(Buffer_Ret,"%g",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%g",d[i]);
        break;
      case FLOAT64:
        len = sprintf(Buffer_Ret,"%g",d[n-1]);
        for (i = n-2; i >= 0; i--)
          len += sprintf(Buffer_Ret+len,",%g",d[i]);
        break;
  }

  Free_Array(point);

  return (Buffer_Ret);
}

Coordinate *G(Coord1)(Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 1;
  coord  = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  return (coord);
}

Coordinate *G(Coord2)(Dimn_Type d2, Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 2;
  coord  = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  c[1]   = d2;
  return (coord);
}

Coordinate *G(Coord3)(Dimn_Type d3, Dimn_Type d2, Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 3;
  coord  = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  c[1]   = d2;
  c[2]   = d3;
  return (coord);
}

Coordinate *G(Coord4)(Dimn_Type d4, Dimn_Type d3, Dimn_Type d2, Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 4;
  coord  = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  c[1]   = d2;
  c[2]   = d3;
  c[3]   = d4;
  return (coord);
}

Indx_Type Coord2Idx(Coordinate *F(point))
{ Dimn_Type *x, y;
  Indx_Type  p;
  int        n, i;

  if (Coord_Dims == NULL)
    { fprintf(stderr,"Coordinate basis is not set (Coord2Idx)\n");
      exit (1);
    }
  if (point->ndims != 1 || point->type != dimn_type[sizeof(Dimn_Type)])
    { fprintf(stderr,"Point is not an integer vector (Coord2Idx)\n");
      exit (1);
    }
  if (point->dims[0] != Coord_Ndim)
    { fprintf(stderr,"Coordinate dimensionality doesn't match that of current basis (Coord2Idx)\n");
      exit (1);
    }

  x = ADIMN(point);
  p = 0;
  for (i = Coord_Ndim-1; i >= 0; i--)
    { y = x[i];
      if (y >= Coord_Dims[i])
        { fprintf(stderr,"%d'th index out of bounds (Coord2Idx)\n",i+1);
          exit (1);
        }
      p = p*Coord_Dims[i] + y; 
    }

  Free_Array(point);

  return (p);
}

Indx_Type Coord2IdxA(Array *a, Coordinate *F(point))
{ Dimn_Type *x, *d, y;
  Indx_Type  p;
  int        n, i;

  if (point->ndims != 1 || point->type != dimn_type[sizeof(Dimn_Type)])
    { fprintf(stderr,"Point is not an integer vector (Coord2IdxA)\n");
      exit (1);
    }

  n = a->ndims;
  d = a->dims;

  if (point->dims[0] != n)
    { fprintf(stderr,"Coordinate dimensionality doesn't match that of array basis (Coord2IdxA)\n");
      exit (1);
    }

  x = ADIMN(point);
  p = 0;
  for (i = n-1; i >= 0; i--)
    { y = x[i];
      if (y >= d[i])
        { fprintf(stderr,"%d'th index out of bounds (Coord2IdxA)\n",i+1);
          exit (1);
        }
      p = p*d[i] + y; 
    }

  Free_Array(point);

  return (p);
}

Coordinate *G(Array_Basis)(Array *a)
{ Array    *coord;
  Dimn_Type dim[1];

  dim[0] = a->ndims;
  coord = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dim);
  memcpy(ADIMN(coord),a->dims,sizeof(Dimn_Type)*a->ndims);
  return (coord);
}

Coordinate *AddCoord(int d, Coordinate *R(M(c)))
{ Dimn_Type n;
  n = c->dims[0];
  allocate_array_data(c,(n+1)*sizeof(Dimn_Type),"AddCoord");
  c->dims[0]  = n+1;
  c->size     = n+1;
  ADIMN(c)[n] = d;
  return (c);
}

Coordinate *G(Idx2Coord)(Indx_Type idx)
{ Dimn_Type   dims[1], m, *l;
  Coordinate *lat;
  int         i;

  if (Coord_Dims == NULL)
    { fprintf(stderr,"Coordinate basis is not set (Idx2Coord)\n");
      exit (1);
    }

  dims[0] = Coord_Ndim;
  lat     = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dims);

  l = ADIMN(lat);
  for (i = 0; i < Coord_Ndim; i++)
    { m = Coord_Dims[i];
      l[i] = idx % m;
      idx /= m;
    }
  if (idx > 0)
    { fprintf(stderr,"Index is out of current basis boundary (Idx2Coord)\n");
      exit (1);
    }
  return (lat);
}

Coordinate *G(Idx2CoordA)(Array *a, Indx_Type idx)
{ Dimn_Type   dims[1], m, *l, *d;
  Coordinate *lat;
  int         i, n;

  n = a->ndims;
  d = a->dims;

  dims[0] = n;
  lat     = Make_Array(PLAIN_KIND,dimn_type[sizeof(Dimn_Type)],1,dims);

  l = ADIMN(lat);
  for (i = 0; i < n; i++)
    { m = d[i];
      l[i] = idx % m;
      idx /= m;
    }
  if (idx > 0)
    { fprintf(stderr,"Index is out of array boundary (Idx2CoordA)\n");
      exit (1);
    }
  return (lat);
}

Value Get_Array_Value(Array *a, Coordinate *coord)
{ Indx_Type p = Coord2IdxA(a,coord);
  switch (a->type) {
      case UINT8:
        return ((Value) (uint64) AUINT8(a)[p]);
      case UINT16:
        return ((Value) (uint64) AUINT16(a)[p]);
      case UINT32:
        return ((Value) (uint64) AUINT32(a)[p]);
      case UINT64:
        return ((Value) (uint64) AUINT64(a)[p]);
      case INT8:
        return ((Value) (int64) AINT8(a)[p]);
      case INT16:
        return ((Value) (int64) AINT16(a)[p]);
      case INT32:
        return ((Value) (int64) AINT32(a)[p]);
      case INT64:
        return ((Value) (int64) AINT64(a)[p]);
      case FLOAT32:
        return ((Value) (double) AFLOAT32(a)[p]);
      case FLOAT64:
        return ((Value) (double) AFLOAT64(a)[p]);
  }
}

void Set_Array_Value(Array *M(a), Coordinate *coord, Value v)
{ Indx_Type p = Coord2IdxA(a,coord);
  switch (a->type) {
      case UINT8:
        AUINT8(a)[p] = v.uval;
        break;
      case UINT16:
        AUINT16(a)[p] = v.uval;
        break;
      case UINT32:
        AUINT32(a)[p] = v.uval;
        break;
      case UINT64:
        AUINT64(a)[p] = v.uval;
        break;
      case INT8:
        AINT8(a)[p] = v.ival;
        break;
      case INT16:
        AINT16(a)[p] = v.ival;
        break;
      case INT32:
        AINT32(a)[p] = v.ival;
        break;
      case INT64:
        AINT64(a)[p] = v.ival;
        break;
      case FLOAT32:
        AFLOAT32(a)[p] = v.rval;
        break;
      case FLOAT64:
        AFLOAT64(a)[p] = v.rval;
        break;
  }
}

Integer_Array *G(Floor_Coord)(Double_Vector *point)
{ Array     *lat;
  double    *p;
  Dimn_Type *c, k;

  if (point->ndims != 1 || point->kind != PLAIN_KIND || point->type != FLOAT64)
    { fprintf(stderr,"Point is not a double vector (Floor_Coord)\n");
      exit (1);
    }

  lat = Make_Array(PLAIN_KIND,INT32,1,point->dims);

  p = AFLOAT64(point);
  c = ADIMN(lat);
  for (k = 0; k < point->dims[0]; k++)
    c[k] = floor(p[k]);

  return (lat);
}

Integer_Array *G(Ceiling_Coord)(Double_Vector *point)
{ Array     *lat;
  double    *p;
  Dimn_Type *c, k;

  if (point->ndims != 1 || point->kind != PLAIN_KIND || point->type != FLOAT64)
    { fprintf(stderr,"Point is not a double vector (Ceiling_Coord)\n");
      exit (1);
    }

  lat = Make_Array(PLAIN_KIND,INT32,1,point->dims);

  p = AFLOAT64(point);
  c = ADIMN(lat);
  for (k = 0; k < point->dims[0]; k++)
    c[k] = ceil(p[k]);

  return (lat);
}

Integer_Array *G(Nearest_Coord)(Double_Vector *point)
{ Array     *lat;
  double    *p;
  Dimn_Type *c, k;

  if (point->ndims != 1 || point->kind != PLAIN_KIND || point->type != FLOAT64)
    { fprintf(stderr,"Point is not a double vector (Floor_Coord)\n");
      exit (1);
    }

  lat = Make_Array(PLAIN_KIND,INT32,1,point->dims);

  p = AFLOAT64(point);
  c = ADIMN(lat);
  for (k = 0; k < point->dims[0]; k++)
    c[k] = round(p[k]);

  return (lat);
}


/****************************************************************************************
 *                                                                                      *
 *  SLICE ITERATOR ROUTINES                                                             *
 *                                                                                      *
 ****************************************************************************************/

typedef struct
  { int         kind;     //  Always COMPLEX_KIND+1 in order to distingusih from an Array
    int         clip;     //  Highest dimension currently outside of slice
    Size_Type   p;        //  Current index
    Coordinate *cnt;      //  Current coordinate (= index)
    Size_Type  *dnc;      //  dnc[i] = displacement to next slice element when at an i boundary
    Array      *beg_ref;  //  References to the beg and end coordinate defining slice ...
    Array      *end_ref;
    Array      *trg_ref;  //  ... and the array the slice is in.
  } Slicer;

static void print_slice(Slicer *s)
{ Dimn_Type *cnt = ADIMN(s->cnt);
  int i;

  printf("Slice %d %llu:",s->clip,s->p);
  for (i = 0; i < s->trg_ref->ndims; i++)
    printf(" %u",cnt[i]);
  printf("\n");
}

Slice *Make_Slice(Array *I(target), Coordinate *C(beg), Coordinate *C(end))
{ Slicer    *slice;
  Dimn_Type *ecrd = ADIMN(end);
  Dimn_Type *bcrd = ADIMN(beg);
  Dimn_Type *dims;
  int        i, ndim;

  ndim = beg->size;
  if (!(target->ndims == ndim || target->ndims-1 == ndim && target->kind != PLAIN_KIND) ||
       beg->dims[0] != end->dims[0])
    { fprintf(stderr,"Target and coordinate dimensionality do not match (Make_Slice)\n");
      exit (1);
    }
  if (end->size != ndim)
    { fprintf(stderr,"Begin and end coordinate dimensionality do not match (Make_Slice)\n");
      exit (1);
    }

  if (ndim == target->ndims-1 && target->kind == COMPLEX_KIND)
    dims = target->dims+1;
  else
    dims = target->dims;

  for (i = 0; i < ndim; i++)
    { if (bcrd[i] > ecrd[i])
        { fprintf(stderr,"beg is not before end in target array (Make_Slice)\n");
          exit (1);
        }
      if (ecrd[i] >= dims[i])
        { fprintf(stderr,"end is not in basis of target array (Make_Slice)\n");
          exit (1);
        }
    }

  if (ndim == target->ndims-1)
    { ndim += 1;
      beg   = AddCoord(0,beg);
      end   = AddCoord(kind_size[target->kind]-1,end);
      if (target->kind == COMPLEX_KIND)
        { Dimn_Type *bcrd = ADIMN(beg);
          Dimn_Type *ecrd = ADIMN(end);
          for (i = ndim-1; i >= 1; i--)
            { bcrd[i] = bcrd[i-1];
              ecrd[i] = ecrd[i-1];
            }
          bcrd[0] = 0;
          ecrd[0] = 1;
        }
    }

  slice = (Slicer *) Guarded_Malloc(sizeof(Slicer),"Make_Slice");
  slice->kind = COMPLEX_KIND+1;
  slice->cnt  = Copy_Array(beg);
  slice->dnc  = (Size_Type *) Guarded_Malloc(sizeof(Size_Type)*target->ndims,"Make_Slice");
  slice->trg_ref = Inc_Array(target);
  slice->beg_ref = beg;
  slice->end_ref = end;

  { Size_Type *dinc = slice->dnc;
    Dimn_Type *bcrd = ADIMN(beg);
    Size_Type  offset, outer;

    offset  = 0;
    outer   = 1;
    for (i = 0; i < ndim; i++)
      { dinc[i] = outer-offset;
        offset += (ecrd[i]-bcrd[i])*outer;
        outer  *= target->dims[i];
      }

    slice->p = Coord2IdxA(target,Inc_Array(beg));
    slice->clip = -1;
  }

  return ((Slice *) slice);
}

void Kill_Slice(Slice *K(slicer))
{ Slicer *slice = (Slicer *) slicer;
  Free_Array(slice->trg_ref);
  Free_Array(slice->beg_ref);
  Free_Array(slice->end_ref);
  Free_Array(slice->cnt);
  free(slice->dnc);
  free(slice);
}

int Is_Slice(Array_Or_Slice *o)
{ return (((Slicer *) o)->kind > COMPLEX_KIND); }

Size_Type Slice_Volume(Array_Or_Slice *o)
{ Slicer *s = (Slicer *) o;
  if (s->kind <= COMPLEX_KIND)
    return (((Array *) s)->size);
  else
    { Dimn_Type *bcrd = AUINT32(s->beg_ref);
      Dimn_Type *ecrd = AUINT32(s->end_ref);
      Size_Type  volume = 1;
      int        i;
      for (i = 0; i < s->trg_ref->ndims; i++)
        volume *= (ecrd[i] - bcrd[i]) + 1;
      return (volume);
    }
}

Indx_Type Slice_Index(Slice *slicer)
{ return (((Slicer *) slicer)->p);  }

Coordinate *Slice_Coordinate(Slice *slicer)
{ return (((Slicer *) slicer)->cnt); }

Coordinate *Slice_First(Slice *slicer)
{ return (((Slicer *) slicer)->beg_ref); }

Coordinate *Slice_Last(Slice *slicer)
{ return (((Slicer *) slicer)->end_ref); }

int Inside_Slice(Slice *slicer)
{ return (((Slicer *) slicer)->clip < 0);  }

Array *Slice_Array(Slice *slicer)
{ return (((Slicer *) slicer)->trg_ref);  }

int Slice_Kind(Slice *slicer)
{ Slicer *slice = (Slicer *) slicer;
  int     ndims, kind;

  ndims = slice->trg_ref->ndims;
  kind  = slice->trg_ref->kind;
  if (kind == RGB_KIND || kind == RGBA_KIND)
    { if (ADIMN(slice->beg_ref)[ndims-1] != 0 ||
          ADIMN(slice->end_ref)[ndims-1] != kind_size[kind]-1)
        kind = PLAIN_KIND;
    }
  else if (kind == COMPLEX_KIND)
    { if (ADIMN(slice->beg_ref)[0] != 0 || ADIMN(slice->end_ref)[0] != 1)
        kind = PLAIN_KIND;
    }
  return (kind);
}

Coordinate *G(Slice_Basis)(Slice *slicer)
{ Slicer     *slice = (Slicer *) slicer;
  Dimn_Type  *bcrd, *bval;
  Coordinate *basis;
  int         i;

  basis = Copy_Array(slice->end_ref);
  bval  = ADIMN(basis);
  bcrd  = ADIMN(slice->beg_ref);
  for (i = 0; i < slice->trg_ref->ndims; i++)
    bval[i] = (bval[i] - bcrd[i]) + 1;
  return (basis);
}

int Set_Slice_To_Index(Slice *slicer, Size_Type idx)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *bcrd = ADIMN(slice->beg_ref);
  Dimn_Type *ecrd = ADIMN(slice->end_ref);
  Dimn_Type *cnt  = ADIMN(slice->cnt);
  int        ndim = slice->trg_ref->ndims;
  Dimn_Type  d, c;
  int        i;

  if (idx >= slice->trg_ref->size)
    { fprintf(stderr,"Index is not in target array basis (Set_Slice_To_Index)\n");
      exit (1);
    }

  slice->p    = idx;
  slice->clip = -1;
  for (i = 0; i < ndim; i++)
    { d = slice->trg_ref->dims[i];
      cnt[i] = c = idx % d;
      if (c < bcrd[i] || c > ecrd[i])
        slice->clip = i;
      idx = idx / d;
    }
  return (slice->clip < 0);
}

Indx_Type Set_Slice_To_First(Slice *slicer)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *bcrd = ADIMN(slice->beg_ref);
  Dimn_Type *cnt  = ADIMN(slice->cnt);
  Dimn_Type *dim  = slice->trg_ref->dims;
  int        ndim = slice->trg_ref->ndims;
  int        i;

  slice->p = 0;
  for (i = ndim-1; i >= 0; i--)
    { cnt[i] = bcrd[i];
      slice->p = slice->p * dim[i] + bcrd[i];
    }
  slice->clip = -1;
  return (slice->p);
}

Indx_Type Set_Slice_To_Last(Slice *slicer)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *ecrd = ADIMN(slice->end_ref);
  Dimn_Type *cnt  = ADIMN(slice->cnt);
  Dimn_Type *dim  = slice->trg_ref->dims;
  int        ndim = slice->trg_ref->ndims;
  int        i;

  slice->p = 0;
  for (i = ndim-1; i >= 0; i--)
    { cnt[i] = ecrd[i];
      slice->p = slice->p * dim[i] + ecrd[i];
    }
  slice->clip = -1;
  return (slice->p);
}

Indx_Type Next_Slice_Index(Slice *slicer)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *bcrd = ADIMN(slice->beg_ref);
  Dimn_Type *ecrd = ADIMN(slice->end_ref);
  Dimn_Type *cnt  = ADIMN(slice->cnt);
  int        ndim = slice->trg_ref->ndims;
  int        i;

  if (slice->clip >= 0)
    { fprintf(stderr,"Must be in slice to move to next position (Next_Slice_Index)\n");
      exit (1);
    }

  for (i = 0; i < ndim; i++)
    if (++cnt[i] > ecrd[i])
      cnt[i] = bcrd[i];
    else
      return (slice->p += slice->dnc[i]);
  slice->p = Coord2IdxA(slice->trg_ref,Inc_Array(slice->beg_ref));
  return (slice->p);
}

Indx_Type Prev_Slice_Index(Slice *slicer)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *bcrd = ADIMN(slice->beg_ref);
  Dimn_Type *ecrd = ADIMN(slice->end_ref);
  Dimn_Type *cnt  = ADIMN(slice->cnt);
  int        ndim = slice->trg_ref->ndims;
  int        i;

  if (slice->clip >= 0)
    { fprintf(stderr,"Must be in slice to move to next position (Prev_Slice_Index)\n");
      exit (1);
    }

  for (i = 0; i < ndim; i++)
    if (--cnt[i] < bcrd[i])
      cnt[i] = ecrd[i];
    else
      return (slice->p -= slice->dnc[i]);
  slice->p = Coord2IdxA(slice->trg_ref,Inc_Array(slice->end_ref));
  return (slice->p);
}

int Inc_Slice(Slice *slicer)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *tcrd = slice->trg_ref->dims;
  Dimn_Type *bcrd = ADIMN(slice->beg_ref);
  Dimn_Type *ecrd = ADIMN(slice->end_ref);
  Dimn_Type *cnt  = ADIMN(slice->cnt);
  int        ndim = slice->trg_ref->ndims;
  int        i, nclip, clip;
  
  clip  = slice->clip;
  nclip = -1;
  for (i = 0; i < ndim; i++)
    if (++cnt[i] == tcrd[i])
      { cnt[i] = 0;
        if (cnt[i] < bcrd[i])
          nclip = i;
        else if (clip == i)
          clip = -1;
      }
    else
      { if (cnt[i] > ecrd[i])
          nclip = i;
        else if (clip == i && cnt[i] >= bcrd[i])
          clip = -1;
        break;
      }
  if (nclip > clip)
    clip = nclip;
  slice->clip = clip;
  slice->p   += 1;
  return (clip < 0);
}

int Dec_Slice(Slice *slicer)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *tcrd = slice->trg_ref->dims;
  Dimn_Type *bcrd = ADIMN(slice->beg_ref);
  Dimn_Type *ecrd = ADIMN(slice->end_ref);
  Dimn_Type *cnt  = ADIMN(slice->cnt);
  int        ndim = slice->trg_ref->ndims;
  int        i, nclip, clip;
  
  clip  = slice->clip;
  nclip = -1;
  for (i = 0; i < ndim; i++)
    if (cnt[i]-- == 0)
      { cnt[i] = tcrd[i]-1;
        if (cnt[i] > ecrd[i])
          nclip = i;
        else if (clip == i)
          clip = -1;
      }
    else
      { if (cnt[i] < bcrd[i])
          nclip = i;
        else if (clip == i && cnt[i] <= ecrd[i])
          clip = -1;
        break;
      }
  if (nclip > clip)
    clip = nclip;
  slice->clip = clip;
  slice->p   -= 1;
  return (clip < 0);
}


/****************************************************************************************
 *                                                                                      *
 *  DISPLAY AN ARRAY                                                                    *
 *                                                                                      *
 ****************************************************************************************/

static char *type_name[] = { "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32",
                             "int64", "float32", "float64" };

static int   Uindent;
static FILE *Uoutput;

static void Uhandler(Array *a)
{ int       i;
  Size_Type bytes;

  fprintf(Uoutput,"%*s%2d : %u",Uindent,"",Array_Refcount(a),a->dims[a->ndims-1]);
  for (i = a->ndims-2; i >= 0; i--)
    fprintf(Uoutput," x %u",a->dims[i]);
  fprintf(Uoutput," %s",type_name[a->type]);
  bytes = a->size * type_size[a->type];
  if (bytes < 1.e3)
    fprintf(Uoutput," = %llu",bytes);
  else if (bytes < 1.e6)
    fprintf(Uoutput," = %.1fKb",bytes/1.e3);
  else if (bytes < 1.e9)
    fprintf(Uoutput," = %.1fMb",bytes/1.e6);
  else 
    fprintf(Uoutput," = %.2fGb",bytes/1.e9);
  if (a->text != NULL && a->text[0] != '\0')
    fprintf(Uoutput," : '%.*s'",50,a->text);
  fprintf(Uoutput,"\n");
}

void Print_Inuse_List(FILE *output, int indent)
{ Uoutput = output;
  Uindent = indent;
  Array_List(Uhandler);
}

void Print_Array(Array_Or_Slice *o, FILE *output, int indent, char *format)
{ Indx_Type   i, j, e, f;
  Size_Type   area;
  Dimn_Type  *b, *c, *t;
  Slice      *s = (Slice *) o;
  Array      *a = (Array *) o;
  Coordinate *beg, *end;
  int         d0, d1, d2, od, kind, ndims;

  if (Is_Slice(o))
    { a     = Slice_Array(s);
      ndims = a->ndims;
      kind  = Slice_Kind(s);
      beg   = Slice_First(s);
      end   = Slice_Last(s);
      if (kind == RGB_KIND || kind == RGBA_KIND)
        { ADIMN(end)[ndims-1] = 0;
          e = Coord2IdxA(a,Inc_Array(end));
          ADIMN(end)[ndims-1] = kind_size[kind]-1;
        }
      else
        e = Coord2IdxA(a,Inc_Array(end));
    }
  else
    { ndims = a->ndims;
      kind  = a->kind;
      beg   = Idx2CoordA(a,0);
      if (kind != COMPLEX_KIND)
        end = Idx2CoordA(a,a->size/kind_size[kind]-1);
      else
        end = Idx2CoordA(a,a->size-1);
      s = Make_Slice(a,beg,end);
      e = Coord2IdxA(a,Inc_Array(end));
    }

  if (kind != PLAIN_KIND)
    ndims -= 1;
  d0 = (kind == COMPLEX_KIND);
  d1 = (ndims >= 2) + d0;
  d2 = d1+1;
  od = (ndims-1) + d0;
  area = a->size/kind_size[kind];

  b = ADIMN(beg);
  t = ADIMN(end);
  c = ADIMN(Slice_Coordinate(s));

  if (Is_Slice(o))
    { fprintf(output,"\n%*sSlice ",indent,"");
      if (ndims >= 2)
        fprintf(output,"[%u,%u] x ",b[d1],t[d1]);
      fprintf(output,"[%u,%u]\n",b[d0],t[d0]);
    }

  switch (kind) {
      case PLAIN_KIND:
        switch (a->type) {
            case UINT8:
              { uint8 *v = (uint8 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case UINT16:
              { uint16 *v = (uint16 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case UINT32:
              { uint32 *v = (uint32 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case UINT64:
              { uint64 *v = (uint64 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case INT8:
              { int8 *v = (int8 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case INT16:
              { int16 *v = (int16 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case INT32:
              { int32 *v = (int32 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case INT64:
              { int64 *v = (int64 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT32:
              { float32 *v = (float32 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT64:
              { float64 *v = (float64 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                    if (i == e) break;
                  }
                break;
              }
        }
        break;
      case RGB_KIND:
        switch (a->type) {
            case UINT8:
              { uint8 *v = (uint8 *) (a->data);
                uint8 *w = v + area;             
                uint8 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case UINT16:
              { uint16 *v = (uint16 *) (a->data);
                uint16 *w = v + area;             
                uint16 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case UINT32:
              { uint32 *v = (uint32 *) (a->data);
                uint32 *w = v + area;             
                uint32 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case UINT64:
              { uint64 *v = (uint64 *) (a->data);
                uint64 *w = v + area;             
                uint64 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT8:
              { int8 *v = (int8 *) (a->data);
                int8 *w = v + area;             
                int8 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT16:
              { int16 *v = (int16 *) (a->data);
                int16 *w = v + area;             
                int16 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT32:
              { int32 *v = (int32 *) (a->data);
                int32 *w = v + area;             
                int32 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT64:
              { int64 *v = (int64 *) (a->data);
                int64 *w = v + area;             
                int64 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT32:
              { float32 *v = (float32 *) (a->data);
                float32 *w = v + area;             
                float32 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT64:
              { float64 *v = (float64 *) (a->data);
                float64 *w = v + area;             
                float64 *x = w + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
        }
        break;
      case RGBA_KIND:
        switch (a->type) {
            case UINT8:
              { uint8 *v = (uint8 *) (a->data);
                uint8 *w = v + area;             
                uint8 *x = w + area;             
                uint8 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case UINT16:
              { uint16 *v = (uint16 *) (a->data);
                uint16 *w = v + area;             
                uint16 *x = w + area;             
                uint16 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case UINT32:
              { uint32 *v = (uint32 *) (a->data);
                uint32 *w = v + area;             
                uint32 *x = w + area;             
                uint32 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case UINT64:
              { uint64 *v = (uint64 *) (a->data);
                uint64 *w = v + area;             
                uint64 *x = w + area;             
                uint64 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT8:
              { int8 *v = (int8 *) (a->data);
                int8 *w = v + area;             
                int8 *x = w + area;             
                int8 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT16:
              { int16 *v = (int16 *) (a->data);
                int16 *w = v + area;             
                int16 *x = w + area;             
                int16 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT32:
              { int32 *v = (int32 *) (a->data);
                int32 *w = v + area;             
                int32 *x = w + area;             
                int32 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case INT64:
              { int64 *v = (int64 *) (a->data);
                int64 *w = v + area;             
                int64 *x = w + area;             
                int64 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT32:
              { float32 *v = (float32 *) (a->data);
                float32 *w = v + area;             
                float32 *x = w + area;             
                float32 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT64:
              { float64 *v = (float64 *) (a->data);
                float64 *w = v + area;             
                float64 *x = w + area;             
                float64 *y = x + area;             
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[i]);
                      fprintf(output,",");
                      fprintf(output,format,w[i]);
                      fprintf(output,",");
                      fprintf(output,format,x[i]);
                      fprintf(output,",");
                      fprintf(output,format,y[i]);
                      fprintf(output,"]");
                    if (i == e) break;
                  }
                break;
              }
        }
        break;
      case COMPLEX_KIND:
        switch (a->type) {
            case UINT8:
              { uint8 *v = (uint8 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case UINT16:
              { uint16 *v = (uint16 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case UINT32:
              { uint32 *v = (uint32 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case UINT64:
              { uint64 *v = (uint64 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case INT8:
              { int8 *v = (int8 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case INT16:
              { int16 *v = (int16 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case INT32:
              { int32 *v = (int32 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case INT64:
              { int64 *v = (int64 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT32:
              { float32 *v = (float32 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
            case FLOAT64:
              { float64 *v = (float64 *) (a->data);
                       
                for (i = f = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                  { if (c[d1] == b[d1] && c[d0] == b[d0])
                      { if (i > f)
                          if (b[d1] == t[d1])
                            fprintf(output," }\n",indent,"");
                          else
                            fprintf(output,"\n%*s}\n",indent,"");
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            for (j = od; j > d2; j--)
                              fprintf(output,"%u,",c[j]);
                            fprintf(output,"%u)",c[j]);
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (c[d0] == b[d0])
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[i]);
                      fprintf(output," + ");
                      i = Next_Slice_Index(s);
                      fprintf(output,format,v[i]);
                      fprintf(output,"i");
                    if (i == e) break;
                  }
                break;
              }
        }
        break;
  }

  if (b[d1] == t[d1])
    fprintf(output," }\n");
  else
    fprintf(output,"\n%*s}\n",indent,"");

  if (!Is_Slice(o))
    Kill_Slice(s);
}


/****************************************************************************************
 *                                                                                      *
 *  MODIFY TEXT DESCRIPTIONS                                                            *
 *                                                                                      *
 ****************************************************************************************/

void Set_Array_Text(Array *M(a), char *text)
{ int len = strlen(text)+1;
  allocate_array_text(a,len,"Set_Array_Text");
  a->tlen = len;
  strcpy(a->text,text);
}

void Append_To_Array_Text(Array *M(a), char *text)
{ int sen = strlen(a->text);
  allocate_array_text(a,sen+a->tlen,"Append_To_Array_Text");
  a->tlen += sen;
  strcpy(a->text+sen,text);
}


/****************************************************************************************
 *                                                                                      *
 *  SUB-PLANE SELECTION                                                                 *
 *                                                                                      *
 ****************************************************************************************/

static char Empty_String[1] = { 0 };

Array_Bundle *Get_Array_Plane(Array *a, Dimn_Type plane)
{ static Array_Bundle My_Array;

  Dimn_Type nplanes = a->dims[a->ndims-1];
  Size_Type offset  = array_dsize(a)/nplanes;

  if (plane >= nplanes || a->ndims <= 1 /* || plane < 0 */)
    return (NULL);
  My_Array.type   = a->type;
  My_Array.ndims  = a->ndims-1;
  My_Array.dims   = a->dims;
  My_Array.size   = a->size / nplanes;
  My_Array.tlen   = 1;
  My_Array.text   = Empty_String;
  My_Array.data   = a->data + plane*offset;

  My_Array.scale  = a->scale;
  if (a->kind == COMPLEX_KIND && a->ndims > 0)
    My_Array.kind   = COMPLEX_KIND;
  else
    My_Array.kind   = PLAIN_KIND;

  return (&My_Array);
}


/****************************************************************************************
 *                                                                                      *
 *  COMPUTE RANGES AND SCALE IMAGES                                                     *
 *                                                                                      *
 ****************************************************************************************/

//  Compute min and max values in 'a' of type 'type' with 'length' elements

static Range_Bundle *array_range(Array_Or_Slice *o)
{ static    Range_Bundle My_Range; 
  Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) o;

  if (Is_Slice(o))
    a = Slice_Array(s);

  switch (a->type) {
      case UINT8:
        { uint8 *d = AUINT8(a);
          uint8  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.uval = max;
          My_Range.minval.uval = min;
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(a);
          uint16  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.uval = max;
          My_Range.minval.uval = min;
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(a);
          uint32  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.uval = max;
          My_Range.minval.uval = min;
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(a);
          uint64  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.uval = max;
          My_Range.minval.uval = min;
          break;
        }
      case INT8:
        { int8 *d = AINT8(a);
          int8  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.ival = max;
          My_Range.minval.ival = min;
          break;
        }
      case INT16:
        { int16 *d = AINT16(a);
          int16  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.ival = max;
          My_Range.minval.ival = min;
          break;
        }
      case INT32:
        { int32 *d = AINT32(a);
          int32  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.ival = max;
          My_Range.minval.ival = min;
          break;
        }
      case INT64:
        { int64 *d = AINT64(a);
          int64  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.ival = max;
          My_Range.minval.ival = min;
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(a);
          float32  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.rval = max;
          My_Range.minval.rval = min;
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(a);
          float64  x, min, max;
  
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              i = Set_Slice_To_First(s);
              min = max = d[i];
              for (i = Next_Slice_Index(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                  if (i == e) break;
                }
            }
          else
            { min = max = d[0];
              for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
            }
          My_Range.maxval.rval = max;
          My_Range.minval.rval = min;
          break;
        }
  }

  return (&My_Range);
}

Range_Bundle *Array_Range(Array_Or_Slice *a)
{ static Range_Bundle My_Range;

  My_Range = *array_range(a);
  return (&My_Range);
}

Array_Or_Slice *Scale_Array(Array_Or_Slice *R(M(o)), double factor, double offset)
{ Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) o;

  if (Is_Slice(o))
    a = Slice_Array(s);

  switch (a->type) {
      case UINT8:
        { uint8 *d = AUINT8(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case INT8:
        { int8 *d = AINT8(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case INT16:
        { int16 *d = AINT16(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case INT32:
        { int32 *d = AINT32(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case INT64:
        { int64 *d = AINT64(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = factor * (d[i] + offset);
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = factor * (d[i] + offset);
          break;
        }
  }

  return (o);
}

Array_Or_Slice *Scale_Array_To_Range(Array_Or_Slice *R(M(o)), Value min, Value max)
{ Range_Bundle crn;
  double       f;
  Slice       *s = (Slice *) o;
  Array       *a = (Array *) o;

  if (a->kind > COMPLEX_KIND)
    a = Slice_Array(s);

  crn = *array_range(o);
  switch (a->type) {
      case UINT8:
        if (crn.maxval.uval == crn.minval.uval)
          return (a);
        if (min.uval == max.uval)
          return (a);
        f  = max.uval-min.uval;
        f /= crn.maxval.uval-crn.minval.uval;
        return (Scale_Array(o,f,min.uval/f-crn.minval.uval));
      case UINT16:
        if (crn.maxval.uval == crn.minval.uval)
          return (a);
        if (min.uval == max.uval)
          return (a);
        f  = max.uval-min.uval;
        f /= crn.maxval.uval-crn.minval.uval;
        return (Scale_Array(o,f,min.uval/f-crn.minval.uval));
      case UINT32:
        if (crn.maxval.uval == crn.minval.uval)
          return (a);
        if (min.uval == max.uval)
          return (a);
        f  = max.uval-min.uval;
        f /= crn.maxval.uval-crn.minval.uval;
        return (Scale_Array(o,f,min.uval/f-crn.minval.uval));
      case UINT64:
        if (crn.maxval.uval == crn.minval.uval)
          return (a);
        if (min.uval == max.uval)
          return (a);
        f  = max.uval-min.uval;
        f /= crn.maxval.uval-crn.minval.uval;
        return (Scale_Array(o,f,min.uval/f-crn.minval.uval));
      case INT8:
        if (crn.maxval.ival == crn.minval.ival)
          return (a);
        if (min.ival == max.ival)
          return (a);
        f  = max.ival-min.ival;
        f /= crn.maxval.ival-crn.minval.ival;
        return (Scale_Array(o,f,min.ival/f-crn.minval.ival));
      case INT16:
        if (crn.maxval.ival == crn.minval.ival)
          return (a);
        if (min.ival == max.ival)
          return (a);
        f  = max.ival-min.ival;
        f /= crn.maxval.ival-crn.minval.ival;
        return (Scale_Array(o,f,min.ival/f-crn.minval.ival));
      case INT32:
        if (crn.maxval.ival == crn.minval.ival)
          return (a);
        if (min.ival == max.ival)
          return (a);
        f  = max.ival-min.ival;
        f /= crn.maxval.ival-crn.minval.ival;
        return (Scale_Array(o,f,min.ival/f-crn.minval.ival));
      case INT64:
        if (crn.maxval.ival == crn.minval.ival)
          return (a);
        if (min.ival == max.ival)
          return (a);
        f  = max.ival-min.ival;
        f /= crn.maxval.ival-crn.minval.ival;
        return (Scale_Array(o,f,min.ival/f-crn.minval.ival));
      case FLOAT32:
        if (crn.maxval.rval == crn.minval.rval)
          return (a);
        if (min.rval == max.rval)
          return (a);
        f  = max.rval-min.rval;
        f /= crn.maxval.rval-crn.minval.rval;
        return (Scale_Array(o,f,min.rval/f-crn.minval.rval));
      case FLOAT64:
        if (crn.maxval.rval == crn.minval.rval)
          return (a);
        if (min.rval == max.rval)
          return (a);
        f  = max.rval-min.rval;
        f /= crn.maxval.rval-crn.minval.rval;
        return (Scale_Array(o,f,min.rval/f-crn.minval.rval));
  }
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY SCALAR AND EL-BY-EL OPERATORS                                                 *
 *                                                                                      *
 ****************************************************************************************/

Array_Or_Slice *Array_Op_Scalar(Array_Or_Slice *R(M(o)), Operator op, Value_Type type, Value value)
{ Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) o;
  uint64    uval;
  int64     ival;
  double    rval;
  Size_Type area;
  int       alice;

  if (alice = Is_Slice(o))
    a = Slice_Array(s);

  if (op == LSH_OP || op == RSH_OP)
    { if (a->type >= FLOAT32)
        { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Scalar)\n");
          exit (1);
        }
    }

  if (type == UVAL)
    uval = value.uval;
  else if (type == IVAL)
    ival = value.ival;
  else
    rval = value.rval;
  
  area = a->size;
  if (alice)
    e = Set_Slice_To_Last(s);

  switch (a->type) {
      case UINT8:
        { uint8 *d = AUINT8(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case INT8:
        { int8 *d = AINT8(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case INT16:
        { int16 *d = AINT16(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case INT32:
        { int32 *d = AINT32(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case INT64:
        { int64 *d = AINT64(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) uval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) uval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) ival);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) ival);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] <<= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] <<= ((int) rval);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] >>= ((int) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] >>= ((int) rval);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(a);
          switch (type) {
              case UVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = uval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += uval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= uval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= uval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= uval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) uval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) uval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > uval) d[i] = uval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < uval) d[i] = uval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < uval) d[i] = uval;
                      break;
                }
                break;
              case IVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = ival;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += ival;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= ival;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= ival;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= ival;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) ival);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) ival);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > ival) d[i] = ival;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < ival) d[i] = ival;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < ival) d[i] = ival;
                      break;
                }
                break;
              case RVAL:
                switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = rval;
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] += rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] += rval;
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] -= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] -= rval;
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] *= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] *= rval;
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] /= rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] /= rval;
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { d[i] = pow((double) d[i],(double) rval);
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            d[i] = pow((double) d[i],(double) rval);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { ;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] > rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] > rval) d[i] = rval;
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                            { if (d[i] < rval) d[i] = rval;
                              if (i == e) break;
                            }
                      else
                        for (i = 0; i < area; i++)
                            if (d[i] < rval) d[i] = rval;
                      break;
                }
                break;
          }
          break;
        }
  }

  return (o);
}

Array_Or_Slice *Complex_Op_Scalar(Array_Or_Slice *R(M(o)), Operator op,
                                  Value_Type type, Value rpart, Value ipart)
{ Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) o;
  int       kind, alice;
  Indx_Type area;
  double    mag, ang;
  double    mgr, agr;
  

  if (alice = Is_Slice(o))
    { a    = Slice_Array(s);
      kind = Slice_Kind(s);
    }
  else
    kind = a->kind;

  if (kind != COMPLEX_KIND)
    { fprintf(stderr,"Array a must be of COMPLEX kind (Complex_Op_Scalar)\n");
      exit (1);
    }

  if (op == LSH_OP || op == RSH_OP)
    { if (a->type >= FLOAT32)
        { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Scalar)\n");
          exit (1);
        }
    }
  
  area = a->size;
  if (alice)
    e = Set_Slice_To_Last(s);

  switch (a->type) {
    case UINT8:
      { uint8 *d = AUINT8(a);
        uint8 *D = d+1;
        uint8  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case UINT16:
      { uint16 *d = AUINT16(a);
        uint16 *D = d+1;
        uint16  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case UINT32:
      { uint32 *d = AUINT32(a);
        uint32 *D = d+1;
        uint32  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case UINT64:
      { uint64 *d = AUINT64(a);
        uint64 *D = d+1;
        uint64  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT8:
      { int8 *d = AINT8(a);
        int8 *D = d+1;
        int8  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT16:
      { int16 *d = AINT16(a);
        int16 *D = d+1;
        int16  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT32:
      { int32 *d = AINT32(a);
        int32 *D = d+1;
        int32  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT64:
      { int64 *d = AINT64(a);
        int64 *D = d+1;
        int64  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] <<= ((int) rp);
                        D[i] <<= ((int) ip);
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] >>= ((int) rp);
                        D[i] >>= ((int) ip);
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case FLOAT32:
      { float32 *d = AFLOAT32(a);
        float32 *D = d+1;
        float32  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case FLOAT64:
      { float64 *d = AFLOAT64(a);
        float64 *D = d+1;
        float64  dr, di;
        switch (type) {
          case UVAL:
            { uint64 rp = rpart.uval;
              uint64 ip = ipart.uval;
              uint64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = rpart.ival;
              int64 ip = ipart.ival;
              int64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          case RVAL:
            { float64 rp = rpart.rval;
              float64 ip = ipart.rval;
              float64 em = rp*rp + ip*ip;
              switch (op) {
                case SET_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] = rp;
                        D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] = rp;
                        D[i] = ip;
                      }
                  break;
                case ADD_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] += rp;
                        D[i] += ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] += rp;
                        D[i] += ip;
                      }
                  break;
                case SUB_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { d[i] -= rp;
                        D[i] -= ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { d[i] -= rp;
                        D[i] -= ip;
                      }
                  break;
                case MUL_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = dr*rp - di*ip;
                        D[i] = di*rp + dr*ip;
                      }
                  break;
                case DIV_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (dr*rp + di*ip) / em;
                        D[i] = (di*rp - dr*ip) / em;
                      }
                  break;
                case POW_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = di*di + dr*dr;
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp(-ip*ang);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = mgr * cos(agr);
                        D[i] = mgr * sin(agr);
                      }
                  break;
                case LSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { ;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] > rp) d[i] = rp;
                        if (D[i] > ip) D[i] = ip;
                      }
                  break;
                case MAX_OP:
                  if (alice)
                    for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s))
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                        i = Next_Slice_Index(s);
                        if (i == e) break;
                      }
                  else
                    for (i = 0; i < area; i += 2)
                      { if (d[i] < rp) d[i] = rp;
                        if (D[i] < ip) D[i] = ip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    }

  return (o);
}

#define AOA_BUFLEN 0x4000000

static double AA_Buffer[AOA_BUFLEN];

Array_Or_Slice *Array_Op_Array(Array_Or_Slice *R(M(o)), Operator op, Array_Or_Slice *q)
{ Slice *s = (Slice *) o;
  Slice *t = (Slice *) q;
  Array *a = (Array *) o;
  Array *b = (Array *) q;

  int         alice, blice;
  int         akind, bkind;
  Size_Type   area,  brea, crea;
  Indx_Type   i, j, k;
  Size_Type   volume;
  int         btype;

  if (alice = Is_Slice(o))
    { a = Slice_Array(s);
      akind = Slice_Kind(s);
    }
  else
    akind = a->kind;

  if (blice = Is_Slice(q))
    { b = Slice_Array(t);
      bkind = Slice_Kind(t);
    }
  else
    bkind = b->kind;

  if ((op == LSH_OP || op == RSH_OP) && a->type >= FLOAT32)
    { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Array)\n");
      exit (1);
    }

  area = a->size;
  brea = b->size;
  if (op == SET_OP && a->type == b->type && !alice && !blice)
    { Size_Type as = array_size(a);
      Size_Type bs = array_size(b);
      if (bs >= as)
        memcpy(a->data,b->data,as);
      else
        { for (i = 0; i < as; i += bs)
            if (i+bs > as)
              memcpy(a->data+i,b->data,as-i);
            else
              memcpy(a->data+i,b->data,bs);
        }
      return (o);
    }

  if (b->type <= UINT64)
    btype = UVAL;
  else if (b->type <= INT64)
    btype = IVAL;
  else
    btype = RVAL;

  if (blice)
    j = Set_Slice_To_First(t);
  else
    j = 0;
  if (alice)
    k = Set_Slice_To_First(s);
  else
    k = 0;

  if (alice)
    volume = Slice_Volume(s);
  else
    volume = area;

  switch (btype) {
    case UVAL:
      { uint64 *buffer = (uint64 *) AA_Buffer;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        break;
      }
    case IVAL:
      { int64 *buffer = (int64 *) AA_Buffer;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT8:
                { int8 *e = AINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT16:
                { int16 *e = AINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT32:
                { int32 *e = AINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT64:
                { int64 *e = AINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        break;
      }
    case RVAL:
      { float64 *buffer = (float64 *) AA_Buffer;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT8:
                { int8 *e = AINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT16:
                { int16 *e = AINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT32:
                { int32 *e = AINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT64:
                { int64 *e = AINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case FLOAT32:
                { float32 *e = AFLOAT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case FLOAT64:
                { float64 *e = AFLOAT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] <<= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] <<= (int) buffer[i];
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] >>= (int) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] >>= (int) buffer[i];
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] += buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] += buffer[i];
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] -= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] -= buffer[i];
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] *= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] *= buffer[i];
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] /= buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] /= buffer[i];
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = pow((double) d[k],(double) buffer[i]);
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] > buffer[i]) d[k] = buffer[i];
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(s))
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          if (d[k] < buffer[i]) d[k] = buffer[i];
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        break;
      }
    }

  return (o);
}

Array_Or_Slice *Complex_Op_Array(Array_Or_Slice *R(M(o)), Operator op, Array_Or_Slice *q)
{ Slice *s = (Slice *) o;
  Slice *t = (Slice *) q;
  Array *a = (Array *) o;
  Array *b = (Array *) q;

  int         alice, blice;
  int         akind, bkind;
  Size_Type   area,  brea, crea;
  Indx_Type   i, j, k;
  Size_Type   volume;
  int         btype;
  double      mag, ang;
  double      mgr, agr;

  if (alice = Is_Slice(o))
    { a = Slice_Array(s);
      akind = Slice_Kind(s);
    }
  else
    akind = a->kind;

  if (blice = Is_Slice(q))
    { b = Slice_Array(t);
      bkind = Slice_Kind(t);
    }
  else
    bkind = b->kind;

  if (akind != COMPLEX_KIND)
    { fprintf(stderr,"First array must be complex (Complex_Op_Array)\n");
      exit (1);
    }
  if ((op == LSH_OP || op == RSH_OP) && a->type >= FLOAT32)
    { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Array)\n");
      exit (1);
    }

  if (b->type <= UINT64)
    btype = UVAL;
  else if (b->type <= INT64)
    btype = IVAL;
  else
    btype = RVAL;

  if (blice)
    j = Set_Slice_To_First(t);
  else
    j = 0;
  if (alice)
    k = Set_Slice_To_First(s);
  else
    k = 0;

  area = a->size;
  brea = b->size;
  if (alice)
    volume = Slice_Volume(s);
  else
    volume = area;

  switch (btype) {
    case UVAL:
      { uint64 *buffer = (uint64 *) AA_Buffer;
        uint64 er;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume/2;
            else
              crea = AOA_BUFLEN/2;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  uint8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  uint16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  uint32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  uint64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  int8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  int16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  int32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  int64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  float32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  float64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= 2*crea;
          }
        break;
      }
    case IVAL:
      { int64 *buffer = (int64 *) AA_Buffer;
        int64 er;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume/2;
            else
              crea = AOA_BUFLEN/2;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT8:
                { int8 *e = AINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT16:
                { int16 *e = AINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT32:
                { int32 *e = AINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT64:
                { int64 *e = AINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  uint8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  uint16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  uint32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  uint64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  int8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  int16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  int32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  int64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  float32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  float64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= 2*crea;
          }
        break;
      }
    case RVAL:
      { float64 *buffer = (float64 *) AA_Buffer;
        float64 er;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume/2;
            else
              crea = AOA_BUFLEN/2;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT8:
                { int8 *e = AINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT16:
                { int16 *e = AINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT32:
                { int32 *e = AINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT64:
                { int64 *e = AINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case FLOAT32:
                { float32 *e = AFLOAT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case FLOAT64:
                { float64 *e = AFLOAT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  uint8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  uint16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  uint32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  uint64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  int8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  int16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  int32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  int64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] /= ((int) er);
                            D[k] /= ((int) er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] <<= ((int) er);
                            D[k] <<= ((int) er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] >>= ((int) er);
                            D[k] >>= ((int) er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  float32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  float64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] = er;
                            D[k] = er;
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] += er;
                            D[k] += er;
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] -= er;
                            D[k] -= er;
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            d[k] *= er;
                            D[k] *= er;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            dr = d[k];
                            di = D[k];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] > er) d[k] = er;
                            if (D[k] > er) D[k] = er;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { er = buffer[i];
                            if (d[k] < er) d[k] = er;
                            if (D[k] < er) D[k] = er;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= 2*crea;
          }
        break;
      }
    }

  return (o);
}

Array_Or_Slice *Complex_Op_Complex(Array_Or_Slice *R(M(o)), Operator op, Array_Or_Slice *q)
{ Slice *s = (Slice *) o;
  Slice *t = (Slice *) q;
  Array *a = (Array *) o;
  Array *b = (Array *) q;

  int         alice, blice;
  int         akind, bkind;
  Size_Type   area,  brea, crea;
  Indx_Type   i, j, k;
  Size_Type   volume;
  int         btype;
  double      mag, ang;
  double      mgr, agr;

  if (alice = Is_Slice(o))
    { a = Slice_Array(s);
      akind = Slice_Kind(s);
    }
  else
    akind = a->kind;

  if (blice = Is_Slice(q))
    { b = Slice_Array(t);
      bkind = Slice_Kind(t);
    }
  else
    bkind = b->kind;

  if (akind != COMPLEX_KIND || bkind != COMPLEX_KIND)
    { fprintf(stderr,"Arrays must be complex (Complex_Op_Complex)\n");
      exit (1);
    }
  if ((op == LSH_OP || op == RSH_OP) && a->type >= FLOAT32)
    { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Array)\n");
      exit (1);
    }

  if (b->type <= UINT64)
    btype = UVAL;
  else if (b->type <= INT64)
    btype = IVAL;
  else
    btype = RVAL;

  if (blice)
    j = Set_Slice_To_First(t);
  else
    j = 0;
  if (alice)
    k = Set_Slice_To_First(s);
  else
    k = 0;

  area = a->size;
  brea = b->size;
  if (alice)
    volume = Slice_Volume(s);
  else
    volume = area;

  switch (btype) {
    case UVAL:
      { uint64 *buffer = (uint64 *) AA_Buffer;
        uint64 er, ei, em;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  uint8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  uint16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  uint32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  uint64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  int8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  int16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  int32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  int64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  float32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  float64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        break;
      }
    case IVAL:
      { int64 *buffer = (int64 *) AA_Buffer;
        int64 er, ei, em;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT8:
                { int8 *e = AINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT16:
                { int16 *e = AINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT32:
                { int32 *e = AINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT64:
                { int64 *e = AINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  uint8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  uint16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  uint32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  uint64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  int8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  int16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  int32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  int64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  float32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  float64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        break;
      }
    case RVAL:
      { float64 *buffer = (float64 *) AA_Buffer;
        float64 er, ei, em;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;
            switch (b->type) {
              case UINT8:
                { uint8 *e = AUINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT16:
                { uint16 *e = AUINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT32:
                { uint32 *e = AUINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case UINT64:
                { uint64 *e = AUINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT8:
                { int8 *e = AINT8(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT16:
                { int16 *e = AINT16(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT32:
                { int32 *e = AINT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case INT64:
                { int64 *e = AINT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case FLOAT32:
                { float32 *e = AFLOAT32(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              case FLOAT64:
                { float64 *e = AFLOAT64(b);
                  if (blice)
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j];
                        j = Next_Slice_Index(t);
                      }
                  else
                    for (i = 0; i < crea; i++)
                      { buffer[i] = e[j++];
                        if (j == brea) j = 0;
                      }
                  break;
                }
              }
            switch (a->type) {
              case UINT8:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  uint8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT16:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  uint16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT32:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  uint32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case UINT64:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  uint64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT8:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  int8  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT16:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  int16  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT32:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  int32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case INT64:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  int64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] <<= ((int) buffer[i]);
                            D[k] <<= ((int) buffer[i+1]);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] >>= ((int) buffer[i]);
                            D[k] >>= ((int) buffer[i+1]);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  float32  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  float64  dr, di;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = buffer[i];
                            D[k] = buffer[i+1];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] += buffer[i];
                            D[k] += buffer[i+1];
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] -= buffer[i];
                            D[k] -= buffer[i+1];
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            d[k] = dr*er - di*ei;
                            D[k] = di*er + dr*ei;
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            em   = er*er + ei*ei;
                            d[k] = (dr*er + di*ei) / em;
                            D[k] = (di*er - dr*ei) / em;
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { dr = d[k];
                            di = D[k];
                            er = buffer[i];
                            ei = buffer[i];
                            mag  = di*di + dr*dr;
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp(-ei*ang);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = mgr * cos(agr);
                            D[k] = mgr * sin(agr);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] > buffer[i]) d[k] = buffer[i];
                            if (D[k] > buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(s), k = Next_Slice_Index(s))
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { if (d[k] < buffer[i]) d[k] = buffer[i];
                            if (D[k] < buffer[i+1]) D[k] = buffer[i+1];
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        break;
      }
    }

  return (o);
}

/****************************************************************************************
 *                                                                                      *
 *  APPLYING FUNCTIONS TO ARRAY ELEMENTS                                                *
 *                                                                                      *
 ****************************************************************************************/

Array_Or_Slice *Array_Fct_Val(Array_Or_Slice *R(M(o)), Value (*fct)(Value val))
{ Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) o;

  if (Is_Slice(o))
    a = Slice_Array(s);

  switch (a->type) {
      case UINT8:
        { uint8 *d = AUINT8(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (uint64) d[i]).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (uint64) d[i]).uval;
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (uint64) d[i]).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (uint64) d[i]).uval;
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (uint64) d[i]).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (uint64) d[i]).uval;
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (uint64) d[i]).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (uint64) d[i]).uval;
          break;
        }
      case INT8:
        { int8 *d = AINT8(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (int64) d[i]).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (int64) d[i]).ival;
          break;
        }
      case INT16:
        { int16 *d = AINT16(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (int64) d[i]).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (int64) d[i]).ival;
          break;
        }
      case INT32:
        { int32 *d = AINT32(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (int64) d[i]).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (int64) d[i]).ival;
          break;
        }
      case INT64:
        { int64 *d = AINT64(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (int64) d[i]).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (int64) d[i]).ival;
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (double) d[i]).rval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (double) d[i]).rval;
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(a);
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = fct((Value) (double) d[i]).rval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = fct((Value) (double) d[i]).rval;
          break;
        }
  }

  return (o);
}

Array_Or_Slice *Array_Fct_Idx(Array_Or_Slice *R(M(o)), Value (*fct)(Coordinate *coord))
{ int       n, c;
  Indx_Type p, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) o;
  int       alice;

  if (alice = Is_Slice(o))
    a = Slice_Array(s);
  else
    s = Make_Slice(a,Idx2CoordA(a,0),Idx2CoordA(a,a->size-1));

  switch (a->type) {
      case UINT8:
        { uint8 *d = AUINT8(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case INT8:
        { int8 *d = AINT8(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case INT16:
        { int16 *d = AINT16(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case INT32:
        { int32 *d = AINT32(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case INT64:
        { int64 *d = AINT64(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).rval;
              if (p == e) break;
            }
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = fct(Slice_Coordinate(s)).rval;
              if (p == e) break;
            }
          break;
        }
  }

  if (!alice)
    Kill_Slice(s);

  return (o);
}

//  Threshold values less than cutoff to black, all others to white

Array_Or_Slice *Threshold_Array(Array_Or_Slice *R(M(o)), Value cutoff)
{ Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) o;

  if (Is_Slice(o))
    a = Slice_Array(s);

  switch (a->type) {
      case UINT8:
        { uint8 *d = AUINT8(a);
          uint8  x, c = cutoff.uval;
          uint8  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(a);
          uint16  x, c = cutoff.uval;
          uint16  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(a);
          uint32  x, c = cutoff.uval;
          uint32  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(a);
          uint64  x, c = cutoff.uval;
          uint64  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT8:
        { int8 *d = AINT8(a);
          int8  x, c = cutoff.ival;
          int8  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT16:
        { int16 *d = AINT16(a);
          int16  x, c = cutoff.ival;
          int16  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT32:
        { int32 *d = AINT32(a);
          int32  x, c = cutoff.ival;
          int32  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT64:
        { int64 *d = AINT64(a);
          int64  x, c = cutoff.ival;
          int64  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(a);
          float32  x, c = cutoff.rval;
          float32  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(a);
          float64  x, c = cutoff.rval;
          float64  zero = 0, one = 1;
					
          if (Is_Slice(o))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
  }

  return (o);
}


/****************************************************************************************
 *                                                                                      *
 *  CONVERT IMAGE TYPES                                                                 *
 *                                                                                      *
 ****************************************************************************************/

typedef struct
  { Array_Type type;
    int        scale;
    void      *data;
  } Domain;

#define LIKE_2_LIKE  0   // conversion codes
#define CPLX_2_NORM  1
#define  RGB_2_NORM  2
#define RGBA_2_NORM  3
#define RGBA_2_RGB   4

static void translate(int conversion, Size_Type size, Domain *source, Domain *target, double dscale)
{ Array_Type stype,  ttype;
  void      *sdata, *tdata;
  int        sscale, tscale;
  int        shift;

  stype  = source->type;
  sdata  = source->data;
  sscale = source->scale;

  ttype  = target->type;
  tdata  = target->data;
  tscale = target->scale;

  shift = abs(sscale-tscale);

  if (conversion)
    { Indx_Type p, q;
      double    x, y, z;
      int       ctype;
      double    afactor;

      if (type_size[stype] < type_size[ttype])
        ctype = stype;
      else
        ctype = ttype;

      afactor = 1.;
      if (conversion >= RGBA_2_NORM && stype < FLOAT32)
        { uint64 base = (((uint64) 1) << (sscale-1));
          afactor /= ((base-1) + base);
        }
      if (type_size[stype] >= type_size[ttype])
        { if (sscale > tscale)
            afactor /= (1 << shift);
          else if (tscale > sscale)
            afactor *= (1 << shift);
          else
            afactor *= dscale;
        }

      switch (conversion) {
          case CPLX_2_NORM:
            switch (stype) {
                case UINT8:
                  { uint8 *s0 = (uint8 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT16:
                  { uint16 *s0 = (uint16 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT32:
                  { uint32 *s0 = (uint32 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT64:
                  { uint64 *s0 = (uint64 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT8:
                  { int8 *s0 = (int8 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT16:
                  { int16 *s0 = (int16 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT32:
                  { int32 *s0 = (int32 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT64:
                  { int64 *s0 = (int64 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT32:
                  { float32 *s0 = (float32 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT64:
                  { float64 *s0 = (float64 *) sdata;
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  x = s0[q++];
                                  y = s0[q++];
                                  t0[p] = sqrt(x*x+y*y) * afactor;
                              }
                            break;
                          }
                    }
                    break;
                  }
            }
            break;
          case RGB_2_NORM:
            switch (stype) {
                case UINT8:
                  { uint8 *s0 = (uint8 *) sdata;
                    uint8 *s1 = s0 + size;        
                    uint8 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT16:
                  { uint16 *s0 = (uint16 *) sdata;
                    uint16 *s1 = s0 + size;        
                    uint16 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT32:
                  { uint32 *s0 = (uint32 *) sdata;
                    uint32 *s1 = s0 + size;        
                    uint32 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT64:
                  { uint64 *s0 = (uint64 *) sdata;
                    uint64 *s1 = s0 + size;        
                    uint64 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT8:
                  { int8 *s0 = (int8 *) sdata;
                    int8 *s1 = s0 + size;        
                    int8 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT16:
                  { int16 *s0 = (int16 *) sdata;
                    int16 *s1 = s0 + size;        
                    int16 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT32:
                  { int32 *s0 = (int32 *) sdata;
                    int32 *s1 = s0 + size;        
                    int32 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT64:
                  { int64 *s0 = (int64 *) sdata;
                    int64 *s1 = s0 + size;        
                    int64 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT32:
                  { float32 *s0 = (float32 *) sdata;
                    float32 *s1 = s0 + size;        
                    float32 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT64:
                  { float64 *s0 = (float64 *) sdata;
                    float64 *s1 = s0 + size;        
                    float64 *s2 = s1 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor + .5;                         
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = (.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * afactor;                              
                              }
                            break;
                          }
                    }
                    break;
                  }
            }
            break;
          case RGBA_2_NORM:
            switch (stype) {
                case UINT8:
                  { uint8 *s0 = (uint8 *) sdata;
                    uint8 *s1 = s0 + size;        
                    uint8 *s2 = s1 + size;        
                    uint8 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT16:
                  { uint16 *s0 = (uint16 *) sdata;
                    uint16 *s1 = s0 + size;        
                    uint16 *s2 = s1 + size;        
                    uint16 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT32:
                  { uint32 *s0 = (uint32 *) sdata;
                    uint32 *s1 = s0 + size;        
                    uint32 *s2 = s1 + size;        
                    uint32 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case UINT64:
                  { uint64 *s0 = (uint64 *) sdata;
                    uint64 *s1 = s0 + size;        
                    uint64 *s2 = s1 + size;        
                    uint64 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT8:
                  { int8 *s0 = (int8 *) sdata;
                    int8 *s1 = s0 + size;        
                    int8 *s2 = s1 + size;        
                    int8 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT16:
                  { int16 *s0 = (int16 *) sdata;
                    int16 *s1 = s0 + size;        
                    int16 *s2 = s1 + size;        
                    int16 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT32:
                  { int32 *s0 = (int32 *) sdata;
                    int32 *s1 = s0 + size;        
                    int32 *s2 = s1 + size;        
                    int32 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case INT64:
                  { int64 *s0 = (int64 *) sdata;
                    int64 *s1 = s0 + size;        
                    int64 *s2 = s1 + size;        
                    int64 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT32:
                  { float32 *s0 = (float32 *) sdata;
                    float32 *s1 = s0 + size;        
                    float32 *s2 = s1 + size;        
                    float32 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT64:
                  { float64 *s0 = (float64 *) sdata;
                    float64 *s1 = s0 + size;        
                    float64 *s2 = s1 + size;        
                    float64 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p])) + .5;              
                              }
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;

                              for (q = p = 0; p < size; p++) {
                                  t0[p] = ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                        * (afactor * s3[p]));                   
                              }
                            break;
                          }
                    }
                    break;
                  }
            }
            break;
          case RGBA_2_RGB:
            switch (stype) {
                case UINT8:
                  { uint8 *s0 = (uint8 *) sdata;
                    uint8 *s1 = s0 + size;        
                    uint8 *s2 = s1 + size;        
                    uint8 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case UINT16:
                  { uint16 *s0 = (uint16 *) sdata;
                    uint16 *s1 = s0 + size;        
                    uint16 *s2 = s1 + size;        
                    uint16 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case UINT32:
                  { uint32 *s0 = (uint32 *) sdata;
                    uint32 *s1 = s0 + size;        
                    uint32 *s2 = s1 + size;        
                    uint32 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case UINT64:
                  { uint64 *s0 = (uint64 *) sdata;
                    uint64 *s1 = s0 + size;        
                    uint64 *s2 = s1 + size;        
                    uint64 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case INT8:
                  { int8 *s0 = (int8 *) sdata;
                    int8 *s1 = s0 + size;        
                    int8 *s2 = s1 + size;        
                    int8 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case INT16:
                  { int16 *s0 = (int16 *) sdata;
                    int16 *s1 = s0 + size;        
                    int16 *s2 = s1 + size;        
                    int16 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case INT32:
                  { int32 *s0 = (int32 *) sdata;
                    int32 *s1 = s0 + size;        
                    int32 *s2 = s1 + size;        
                    int32 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case INT64:
                  { int64 *s0 = (int64 *) sdata;
                    int64 *s1 = s0 + size;        
                    int64 *s2 = s1 + size;        
                    int64 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT32:
                  { float32 *s0 = (float32 *) sdata;
                    float32 *s1 = s0 + size;        
                    float32 *s2 = s1 + size;        
                    float32 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
                case FLOAT64:
                  { float64 *s0 = (float64 *) sdata;
                    float64 *s1 = s0 + size;        
                    float64 *s2 = s1 + size;        
                    float64 *s3 = s2 + size;        
  
                    switch (ctype) {
                        case UINT8:
                          { uint8 *t0  = (uint8 *) tdata;
                            uint8 *t1  = t0 + size;       
                            uint8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT16:
                          { uint16 *t0  = (uint16 *) tdata;
                            uint16 *t1  = t0 + size;       
                            uint16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT32:
                          { uint32 *t0  = (uint32 *) tdata;
                            uint32 *t1  = t0 + size;       
                            uint32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case UINT64:
                          { uint64 *t0  = (uint64 *) tdata;
                            uint64 *t1  = t0 + size;       
                            uint64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT8:
                          { int8 *t0  = (int8 *) tdata;
                            int8 *t1  = t0 + size;       
                            int8 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT16:
                          { int16 *t0  = (int16 *) tdata;
                            int16 *t1  = t0 + size;       
                            int16 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT32:
                          { int32 *t0  = (int32 *) tdata;
                            int32 *t1  = t0 + size;       
                            int32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case INT64:
                          { int64 *t0  = (int64 *) tdata;
                            int64 *t1  = t0 + size;       
                            int64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]) + .4999;  
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                                t2[p] = s2[p] * (afactor * s3[p]) + .4999;  
                            break;
                          }
                        case FLOAT32:
                          { float32 *t0  = (float32 *) tdata;
                            float32 *t1  = t0 + size;       
                            float32 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t2[p] = s2[p] * (afactor * s3[p]);          
                            break;
                          }
                        case FLOAT64:
                          { float64 *t0  = (float64 *) tdata;
                            float64 *t1  = t0 + size;       
                            float64 *t2  = t1 + size;       

                              for (p = 0; p < size; p++)
                                t0[p] = s0[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                                t1[p] = s1[p] * (afactor * s3[p]);          
                              for (p = 0; p < size; p++)
                            break;
                          }
                    }
                    break;
                  }
            }
            break;
      }

      sdata = tdata;
      if (type_size[stype] >= type_size[ttype])
        stype = ttype;
      if (conversion == RGBA_2_RGB)
        size *= 3;
  }

  if (ttype != stype || sdata != tdata)
    { Indx_Type p;

      if (sscale > tscale || dscale != 1.)
        switch (stype) {
            case UINT8:
              { uint8 *s = (uint8 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case UINT16:
              { uint16 *s = (uint16 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case UINT32:
              { uint32 *s = (uint32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case UINT64:
              { uint64 *s = (uint64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT8:
              { int8 *s = (int8 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT16:
              { int16 *s = (int16 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT32:
              { int32 *s = (int32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT64:
              { int64 *s = (int64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] >> shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case FLOAT32:
              { float32 *s = (float32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case FLOAT64:
              { float64 *s = (float64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
        }

      else if (sscale < tscale)
        switch (stype) {
            case UINT8:
              { uint8 *s = (uint8 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case UINT16:
              { uint16 *s = (uint16 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case UINT32:
              { uint32 *s = (uint32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case UINT64:
              { uint64 *s = (uint64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT8:
              { int8 *s = (int8 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT16:
              { int16 *s = (int16 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT32:
              { int32 *s = (int32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case INT64:
              { int64 *s = (int64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] << shift;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case FLOAT32:
              { float32 *s = (float32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
            case FLOAT64:
              { float64 *s = (float64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = s[p] * dscale;                 
                        break;
                      }
                }
                break;
              }
        }

      else
        switch (stype) {
            case UINT8:
              { uint8 *s = (uint8 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case UINT16:
              { uint16 *s = (uint16 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case UINT32:
              { uint32 *s = (uint32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case UINT64:
              { uint64 *s = (uint64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case INT8:
              { int8 *s = (int8 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case INT16:
              { int16 *s = (int16 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case INT32:
              { int32 *s = (int32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case INT64:
              { int64 *s = (int64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case FLOAT32:
              { float32 *s = (float32 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
            case FLOAT64:
              { float64 *s = (float64 *) sdata;
                switch (ttype) {
                    case UINT8:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT16:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT32:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case UINT64:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT8:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT16:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT32:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case INT64:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT32:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                    case FLOAT64:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = s[p];
                        break;
                      }
                }
                break;
              }
        }
    }
}

static void imaginary_fill(Size_Type size, Domain *target)
{ Indx_Type p, q;

  switch (target->type) {
      case UINT8:
        { uint8 *d = AUINT8(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT8:
        { int8 *d = AINT8(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT16:
        { int16 *d = AINT16(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT32:
        { int32 *d = AINT32(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT64:
        { int64 *d = AINT64(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
  }
}

static void alpha_fill(Size_Type size, Domain *target, double alpha)
{ Indx_Type p;

  switch (target->type) {
      case UINT8:
        { uint8 *d = AUINT8(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case INT8:
        { int8 *d = AINT8(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case INT16:
        { int16 *d = AINT16(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case INT32:
        { int32 *d = AINT32(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case INT64:
        { int64 *d = AINT64(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = alpha;
          break;
        }
  }
}

typedef struct
  { int    tscale;
    double dscale;
  } Variable_Scale;

static Array *convert_array(Array *sarray, Array_Kind tkind, Array_Type ttype,
                            Variable_Scale *var, int in_place)
{ Domain     source, target;
  Array     *tarray;

  char      *estring;
  int        tdims;
  Size_Type  tels, pels;

  Array_Kind skind  = sarray->kind;
  Array_Type stype  = sarray->type;
  int        sscale = sarray->scale;

  int        tscale;
  double     dscale;

  if (stype < FLOAT32 && ttype < FLOAT32)
    { tscale = var->tscale;
      dscale = 1.;
    }
  else
    { dscale = var->dscale;
      tscale = sarray->scale;
    }

  pels   = sarray->size / kind_size[skind];
  tdims  = (sarray->ndims + (tkind != PLAIN_KIND)) - (skind != PLAIN_KIND);
  tels   = pels * kind_size[tkind];

  if (in_place)
    { estring = "Convert_Array_Inplace";
      tarray  = sarray;
    }
  else
    { estring = "Convert_Array_Copy";
      tarray  = new_array(0,0,1,estring);
      tarray->tlen    = 1;
      tarray->text[0] = '\0';
    }

  if (stype < FLOAT32 && ttype < FLOAT32)
    { if (tscale > bit_size[ttype])
        { fprintf(stderr,"target scale is larger than number of bits in type (%s)\n",estring);
          exit (1);
        }
    }
  else
    { if (fabs(dscale) < 1e-20)
        { fprintf(stderr,"scale factor is nearly 0, i.e. < 1e-20 (%s)\n",estring);
          exit (1);
        }
    }

  allocate_array_data(tarray,tels*type_size[ttype],estring);
  allocate_array_dims(tarray,sizeof(Dimn_Type)*tdims,estring);

  if (INT8 <= stype && stype <= INT64)
    sscale -= 1;
  if (INT8 <= ttype && ttype <= INT64)
    tscale -= 1;

  source.type  = stype;
  source.data  = sarray->data;
  source.scale = sscale;

  target.type  = ttype;
  target.data  = tarray->data;
  if (stype < FLOAT32 && ttype < FLOAT32)
    target.scale = tscale;
  else
    target.scale = sscale;

  if (tkind == skind)
    translate(LIKE_2_LIKE,kind_size[tkind]*pels,&source,&target,dscale);
  else if (tkind == PLAIN_KIND || tkind == COMPLEX_KIND)
    { if (skind == RGB_KIND)
        translate(RGB_2_NORM,pels,&source,&target,dscale);
      else if (skind == RGBA_KIND)
        translate(RGBA_2_NORM,pels,&source,&target,dscale);
      else if (skind == COMPLEX_KIND)
        translate(CPLX_2_NORM,pels,&source,&target,dscale);
      else
        translate(LIKE_2_LIKE,kind_size[tkind]*pels,&source,&target,dscale);
      if (tkind == COMPLEX_KIND)
        imaginary_fill(pels,&target);
    }
  else //  tkind == RGB_KIND || tkind == RGBA_KIND
    { if (skind == COMPLEX_KIND)
        translate(CPLX_2_NORM,pels,&source,&target,dscale);
      else if (skind == RGBA_KIND)
        translate(RGBA_2_RGB,pels,&source,&target,dscale);
      else
        translate(LIKE_2_LIKE,sarray->size,&source,&target,dscale);
      if (skind == PLAIN_KIND || skind == COMPLEX_KIND)
        { int block = type_size[ttype]*pels;
          memcpy(tarray->data + block,sarray->data,block);
          memcpy(tarray->data + 2*block,sarray->data,block);
        }
      if (tkind == RGBA_KIND)
        { double alpha;

          if (stype <= UINT64)
            { uint64 base = (((uint64) 1) << (sscale-1));
              alpha = (base-1) + base;
            }
          else if (stype <= INT64)
            alpha = ((((uint64) 1) << (sscale-1)) - 1);
          else
            alpha = 1.;
          if (stype < FLOAT32 && ttype < FLOAT32)
            if (sscale > tscale)
              alpha /= (((uint64) 1)<<(sscale-tscale));
            else
              alpha *= (((uint64) 1)<<(tscale-sscale));
          else
            alpha *= dscale;
          alpha_fill(pels,&target,alpha);
        }
    }

  { int i, cs, ct, nd;

    cs = (skind == COMPLEX_KIND);
    ct = (tkind == COMPLEX_KIND);
    nd = tdims - (tkind != PLAIN_KIND);
    if (ct > cs)
      { for (i = nd-1; i >= 0; i--)
          tarray->dims[i+ct] = sarray->dims[i+cs];
      }
    else
      { for (i = 0; i < nd; i++)
          tarray->dims[i+ct] = sarray->dims[i+cs];
      }
    if (ct)
      tarray->dims[0] = 2;
    if (!ct && nd != tdims)
      tarray->dims[nd] = kind_size[tkind];
  }

  tarray->size  = tels;
  tarray->kind  = tkind;
  tarray->type  = ttype;
  tarray->ndims = tdims;
  if (ttype < FLOAT32 && stype < FLOAT32)
    { if (ttype <= UINT64)
        tarray->scale = tscale;
      else
        tarray->scale = tscale+1;
    }
  else
    tarray->scale = bit_size[ttype];

  return (tarray);
}

Array *Convert_Array_Inplace(Array *R(M(sarray)), Array_Kind tkind, Array_Type ttype, ...)
{ Variable_Scale var;
  va_list        ap;

  if (sarray->kind == tkind && sarray->type == ttype)
    return (sarray);

  va_start(ap,ttype);
  if (sarray->type < FLOAT32 && ttype < FLOAT32)
    var.tscale = va_arg(ap,int);
  else
    var.dscale = va_arg(ap,double);
  va_end(ap);

  return (convert_array(sarray,tkind,ttype,&var,1));
}

Array *G(Convert_Array_Copy)(Array *sarray, Array_Kind tkind, Array_Type ttype, ...)
{ Variable_Scale var;
  va_list        ap;

  if (sarray->kind == tkind && sarray->type == ttype)
    return (Copy_Array(sarray));

  va_start(ap,ttype);
  if (sarray->type < FLOAT32 && ttype < FLOAT32)
    var.tscale = va_arg(ap,int);
  else
    var.dscale = va_arg(ap,double);
  va_end(ap);

  return (convert_array(sarray,tkind,ttype,&var,0));
}

int Image_Check(Array *array)
{ Indx_Type p, vmax;

  if (array->kind == COMPLEX_KIND)
    { fprintf(stderr,"Array cannot be COMPLEX (Image_Check)\n");
      return (1);
    }

  if (array->type <= UINT64)
    { uint64 base = (((uint64) 1) << (array->scale-1));
      vmax = (base-1) + base;
    }
  else if (array->type <= INT64)
    vmax = ((((uint64) 1) << (array->scale-1)) - 1);

  switch (array->type) {
      case UINT8:
        { uint8 *v = AUINT8(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case UINT16:
        { uint16 *v = AUINT16(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case UINT32:
        { uint32 *v = AUINT32(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case UINT64:
        { uint64 *v = AUINT64(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case INT8:
        { int8 *v = AINT8(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case INT16:
        { int16 *v = AINT16(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case INT32:
        { int32 *v = AINT32(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case INT64:
        { int64 *v = AINT64(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case FLOAT32:
        { float32 *v = AFLOAT32(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > 1.)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case FLOAT64:
        { float64 *v = AFLOAT64(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > 1.)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
  }

  return (0);
}

Array *convert_image(Array *array, Array_Kind kind, Array_Type type, int scale, int in_place)
{ Variable_Scale var;
  Array         *rez;
  int            atype;
  double         fact;

  var.dscale = 1.;
  var.tscale = scale;
  atype = array->type;
  if (atype != type)
    if (type >= FLOAT32)
      { if (array->type <= UINT64)
          { uint64 base = (((uint64) 1) << (array->scale-1));
            var.dscale = 1. / ((base-1) + base);
          }
        else
          var.dscale = 1. / ((((uint64) 1) << (array->scale-1)) - 1);
      }
    else
      { if (type <= UINT64)
          { uint64 base = (((uint64) 1) << (scale-1));
            var.dscale = (base-1) + base;
          }
        else
          var.dscale = ((((uint64) 1) << (scale-1)) - 1);
      }

  rez = convert_array(array,kind,type,&var,in_place);

  if (atype >= FLOAT32 && type < FLOAT32)
    rez->scale = scale;

  return (rez);
}

Array *Convert_Image_Inplace(Array *R(M(array)), Array_Kind kind, Array_Type type, int scale)
{ return (convert_image(array,kind,type,scale,1)); }

Array *G(Convert_Image_Copy)(Array *array, Array_Kind kind, Array_Type type, int scale)
{ return (convert_image(array,kind,type,scale,0)); }

/****************************************************************************************
 *                                                                                      *
 *  ARRAY MULTIPLICATION                                                                *
 *                                                                                      *
 ****************************************************************************************/

Array *G(Array_Multiply)(Array *a, Array *b)
{ Array    *prod;
  int       acmplx, bcmplx;
  Size_Type b_off, a_off;

  { int        i, complex;
    Dimn_Type *pdims;

    acmplx  = (a->kind == COMPLEX_KIND);
    bcmplx  = (b->kind == COMPLEX_KIND);
    complex = acmplx || bcmplx;

    Dimn_Type *adims = a->dims + acmplx;
    Dimn_Type *bdims = b->dims + bcmplx;
    int       andims = a->ndims - acmplx;
    int       bndims = b->ndims - bcmplx;

    if (a->dims[acmplx] != b->dims[b->ndims-1])
      { fprintf(stderr,"Corresponding inner product dimensions for array multiply don't match");
        fprintf(stderr," (Array Multiply)\n");
        exit (1);
      }

    if (a->type != b->type)
      { fprintf(stderr,"Arrays must be of the same type (Array_Multiply)\n");
        exit (1);
      }

    if (complex)
      { prod = make_start(COMPLEX_KIND,a->type,andims+bndims-1,"Array_Multiply");
        prod->dims[0] = 2;
      }
    else
      prod = make_start(PLAIN_KIND,a->type,andims+bndims-2,"Array_Multiply");

    pdims = prod->dims + complex;
    for (i = 1; i < andims; i++)
      pdims[bndims+i-2] = adims[i];
    for (i = 0; i < bndims-1; i++)
      pdims[i] = bdims[i];
    prod->size = array_size(prod);

    allocate_array_data(prod,array_dsize(prod),"Make_Array");

    b_off  = ((b->size / bdims[bndims-1]) >> bcmplx);
    a_off  = adims[0];
  }

  { Size_Type p_off;
    Indx_Type p, q, r, t, k;

    switch (acmplx*2 + bcmplx) {
        case 0:
          p_off = b_off;          
          switch (a->type) {
              case UINT8:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr, si;

                  for (q = 0; q < p_off; q += 1)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
        case 1:
          p_off = (b_off << 1);   
          b_off = p_off;          
          switch (a->type) {
              case UINT8:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
        case 2:
          p_off = (b_off << 1);   
          a_off <<= 1;            
          switch (a->type) {
              case UINT8:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
        case 3:
          p_off = (b_off << 1);   
          b_off = p_off;          
          a_off <<= 1;            
          switch (a->type) {
              case UINT8:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr, si;

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
    }
  }

  return (prod);
}

/****************************************************************************************
 *                                                                                      *
 *  COLOR OR OTHER ARRAY MAPPING                                                        *
 *                                                                                      *
 ****************************************************************************************/


Array *G(Apply_Map)(Array *image, Array *map)
{ Array     *rez;
  Size_Type  inner;

  inner = map->dims[0];

  if (map->ndims < 1)
    { fprintf(stderr,"Map should be at least 1 dimensional (Apply_Map)\n");
      exit (1);
    }
  if (image->type > UINT64 || image->kind != PLAIN_KIND)
    { fprintf(stderr,"image must have unsigned values and be a PLAIN array (Apply_Map)\n");
      exit (1);
    }
  if ((1<<image->scale) != inner)
    { fprintf(stderr,"map length doesn't match image scale (Apply_Map)\n");
      exit (1);
    }

  { int i, j;

    rez = make_start(PLAIN_KIND,map->type,image->ndims+map->ndims-1,"Apply_Map");
    rez->kind  = map->kind;
    rez->scale = map->scale;
    for (i = 0; i < image->ndims; i++)
      rez->dims[i] = image->dims[i];
    for (j = 1, i = image->ndims; i < rez->ndims; i++, j++)
      rez->dims[i] = map->dims[j];
    rez->size = array_size(rez);
    allocate_array_data(rez,array_dsize(rez),"Apply_Map");
    Set_Array_Text(rez,image->text);
  }

  { Indx_Type p, q;

    switch (map->type) {
        case UINT8:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case UINT16:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case UINT32:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case UINT64:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case INT8:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case INT16:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case INT32:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case INT64:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case FLOAT32:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
        case FLOAT64:
          switch (image->type) {
              case UINT8:
                { uint8 *a = AUINT8(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16:
                { uint16 *a = AUINT16(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32:
                { uint32 *a = AUINT32(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64:
                { uint64 *a = AUINT64(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
          }
          break;
    }
  }

  return (rez);
}


/****************************************************************************************
 *                                                                                      *
 *  DOWN SAMPLE CODE                                                                    *
 *                                                                                      *
 ****************************************************************************************/

static void down_sample(Array *source, void *target, Coordinate *F(voxel), Coordinate *F(basis))
{ static int        Max_Dims = 0;
  static Dimn_Type *dcnt, *tcnt;
  static Size_Type *dinc = NULL, *tinc;

  int        i, ndims;
  Dimn_Type *tdims, *vdims, *sdims;
  Size_Type  dsize;

  ndims = source->ndims;
  sdims = source->dims;
  tdims = ADIMN(basis);
  vdims = ADIMN(voxel);

  if (ndims > Max_Dims)
    { Max_Dims = ndims + 10;
      dinc = (Size_Type *) Guarded_Realloc(dinc,(sizeof(Size_Type)+sizeof(Dimn_Type))*2*Max_Dims,
                                           "Down_Sample");
      tinc = dinc + Max_Dims;
      dcnt = ((Dimn_Type *) tinc) + Max_Dims;
      tcnt = dcnt + Max_Dims;
    }

  { Size_Type offset, outer, inner;

    dsize   = vdims[0];
    dcnt[0] = 0;
    dinc[0] = 1;
    tcnt[0] = 0;
    tinc[0] = vdims[0];
    offset  = vdims[0] - 1;
    inner   = 1;
    outer   = sdims[0];
    for (i = 1; i < ndims; i++)
      { dsize  *= vdims[i];
        dcnt[i] = 0;
        dinc[i] = outer - offset;
        tcnt[i] = 0;
        tinc[i] = tinc[i-1] + (sdims[i-1] % vdims[i-1])*inner + (vdims[i]-1)*outer;
        offset += (vdims[i]-1)*outer;
        inner   = outer;
        outer  *= sdims[i];
      }
  }

  { Indx_Type q, p, r;
    Dimn_Type d0 = 0;
    Dimn_Type c0 = vdims[0];

    switch (source->type) {
        case UINT8:
          { uint8 *d = AUINT8(source);
            uint8 *a = (uint8 *) target;
            uint64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case UINT16:
          { uint16 *d = AUINT16(source);
            uint16 *a = (uint16 *) target;
            uint64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case UINT32:
          { uint32 *d = AUINT32(source);
            uint32 *a = (uint32 *) target;
            uint64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case UINT64:
          { uint64 *d = AUINT64(source);
            uint64 *a = (uint64 *) target;
            uint64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case INT8:
          { int8 *d = AINT8(source);
            int8 *a = (int8 *) target;
            int64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case INT16:
          { int16 *d = AINT16(source);
            int16 *a = (int16 *) target;
            int64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case INT32:
          { int32 *d = AINT32(source);
            int32 *a = (int32 *) target;
            int64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case INT64:
          { int64 *d = AINT64(source);
            int64 *a = (int64 *) target;
            int64 sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case FLOAT32:
          { float32 *d = AFLOAT32(source);
            float32 *a = (float32 *) target;
            double sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
        case FLOAT64:
          { float64 *d = AFLOAT64(source);
            float64 *a = (float64 *) target;
            double sum;

            q = r = 0;
            i = 0;
            while (i != ndims)
              { p   = q;
                sum = 0.;
                while (i != ndims)
                  { sum += d[p];
                    if (++d0 < c0)
                      p += 1;
                    else
                      { d0 = 0;
                        for (i = 1; i < ndims; i++)
                          if (++dcnt[i] == vdims[i])
                            dcnt[i] = 0;
                          else
                            { p += dinc[i];
                              break;
                            }
                      }
                  }
          
                a[r++] = sum/dsize;
          
                for (i = 0; i < ndims; i++)
                  if (++tcnt[i] == tdims[i])
                    tcnt[i] = 0;
                  else
                    { q += tinc[i];
                      break;
                    }
              }
            break;
          }
      }
  }

  Free_Array(voxel);
  Free_Array(basis);
}
 
static void check_dsample_args(Array *source, Coordinate *M(point), char *routine)
{ Dimn_Type  *crd;
  int         i, ndims;
 
  ndims = point->size;
  if ( ! (source->ndims == ndims || source->ndims == ndims+1 && source->kind != PLAIN_KIND))
    { fprintf(stderr,"Array dimensionaliy and down sample vector don't match");
      fprintf(stderr," (%s)\n",routine);
      exit (1);
    }

  crd = ADIMN(point);
  for (i = 0; i < source->ndims; i++)
    if (crd[i] == 0)
      { fprintf(stderr,"Down sample vector has a 0-component (%s)\n",routine);
        exit (1);
      }

  if (ndims == source->ndims-1)
    { point = AddCoord(1,point);
      if (source->kind == COMPLEX_KIND)
        { Dimn_Type *scrd = ADIMN(point);
          for (i = ndims; i >= 1; i--)
            scrd[i] = scrd[i-1];
          scrd[0] = 1;
        }
    }
}

Array *Down_Sample_Inplace(Array *R(M(source)), Coordinate *F(point))
{ Coordinate *basis;
  Dimn_Type  *dims, *crd;
  int         i;

  check_dsample_args(source,point,"Down_Sample_Inplace");

  basis = Array_Basis(source);
  dims  = ADIMN(basis);
  crd   = ADIMN(point);
  for (i = 0; i < source->ndims; i++)
    dims[i] /= crd[i];

  down_sample(source,source->data,point,basis);

  for (i = 0; i < source->ndims; i++)
    source->dims[i] = dims[i];
  
  return (source);
}
    

Array *G(Down_Sample_Copy)(Array *source, Coordinate *F(point))
{ Coordinate *basis;
  Array      *target;
  Dimn_Type  *dims, *crd;
  int         i;
 
  check_dsample_args(source,point,"Down_Sample_Copy");

  basis = Array_Basis(source);
  dims  = ADIMN(basis);
  crd   = ADIMN(point);
  for (i = 0; i < source->ndims; i++)
    dims[i] /= crd[i];

  target = Make_Array(source->kind,source->type,source->ndims,dims);

  down_sample(source,target->data,point,basis);

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY CLIPPING CODE                                                                 *
 *                                                                                      *
 ****************************************************************************************/

void clip_array(Array *source, void *target, Coordinate *F(beg), Coordinate *F(end))
{ Slice    *slice;
  Indx_Type p, r, e;

  slice = Make_Slice(source,beg,end);

  switch (source->type) {
      case UINT8:
        { uint8 *d = AUINT8(source);
          uint8 *a = (uint8 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case UINT16:
        { uint16 *d = AUINT16(source);
          uint16 *a = (uint16 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case UINT32:
        { uint32 *d = AUINT32(source);
          uint32 *a = (uint32 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case UINT64:
        { uint64 *d = AUINT64(source);
          uint64 *a = (uint64 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT8:
        { int8 *d = AINT8(source);
          int8 *a = (int8 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT16:
        { int16 *d = AINT16(source);
          int16 *a = (int16 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT32:
        { int32 *d = AINT32(source);
          int32 *a = (int32 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT64:
        { int64 *d = AINT64(source);
          int64 *a = (int64 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case FLOAT32:
        { float32 *d = AFLOAT32(source);
          float32 *a = (float32 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case FLOAT64:
        { float64 *d = AFLOAT64(source);
          float64 *a = (float64 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
  }

  Kill_Slice(slice);
}
 
Array *Clip_Array_Inplace(Array *R(M(source)), Coordinate *F(beg), Coordinate *F(end))
{ Coordinate *shape;
  Dimn_Type  *bcrd, *scrd, *dims, s;
  int         i, ndims;

  ndims = end->size;
  if (ndims != beg->size)
    { fprintf(stderr,"Coordinates are not of same dimensionality (Clip_Array_Copy)\n");
      exit (1);
    }
  if ( ! (source->ndims == ndims || source->ndims == ndims+1 && source->kind != PLAIN_KIND))
    { fprintf(stderr,"Source and coordinate dimensionality do not match (Clip_Array_Inplace)\n");
      exit (1);
    }

  shape = Copy_Array(end);
  bcrd  = ADIMN(beg);
  scrd  = ADIMN(shape);
  for (i = 0; i < ndims; i++)
    scrd[i] -= (bcrd[i]-1);

  clip_array(source,source->data,beg,end);

  dims = source->dims;
  if (source->ndims != ndims)
    { source->size = kind_size[source->kind];
      if (source->kind == COMPLEX_KIND)
        dims += 1;
    }
  else
    source->size = 1;
  for (i = 0; i < ndims; i++)
    { dims[i] = s = scrd[i];
      source->size *= s;
    }

  Free_Array(shape);

  return (source);
}
    

Array *G(Clip_Array_Copy)(Array *source, Coordinate *F(beg), Coordinate *F(end))
{ Coordinate *shape;
  Dimn_Type  *bcrd, *scrd;
  Array      *target;
  int         i, ndims;

  ndims = end->size;
  if (ndims != beg->size)
    { fprintf(stderr,"Coordinates are not of same dimensionality (Clip_Array_Copy)\n");
      exit (1);
    }
  if ( ! (source->ndims == ndims || source->ndims == ndims+1 && source->kind != PLAIN_KIND))
    { fprintf(stderr,"Source and coordinate dimensionality do not match (Clip_Array_Copy)\n");
      exit (1);
    }

  shape = Copy_Array(end);
  bcrd  = ADIMN(beg);
  scrd  = ADIMN(shape);
  for (i = 0; i < ndims; i++)
    scrd[i] -= (bcrd[i]-1);

  if (source->ndims == ndims)
    { target = Make_Array_With_Shape(PLAIN_KIND,source->type,shape);
      target->kind = source->kind;
    }
  else
    target = Make_Array_With_Shape(source->kind,source->type,shape);

  clip_array(source,target->data,beg,end);

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY EXPANDING CODE                                                                *
 *                                                                                      *
 ****************************************************************************************/

void expand_array(Array *target, void *source, Size_Type size, Coordinate *beg, Coordinate *end)
{ Slice     *slice;
  Indx_Type  p;
  int        in;

  slice = Make_Slice(target,beg,end);
  in    = Set_Slice_To_Index(slice,target->size-1);

  switch (target->type) {
      case UINT8:
        { uint8 *a = AUINT8(target);
          uint8 *d = ((uint8 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case UINT16:
        { uint16 *a = AUINT16(target);
          uint16 *d = ((uint16 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case UINT32:
        { uint32 *a = AUINT32(target);
          uint32 *d = ((uint32 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case UINT64:
        { uint64 *a = AUINT64(target);
          uint64 *d = ((uint64 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case INT8:
        { int8 *a = AINT8(target);
          int8 *d = ((int8 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case INT16:
        { int16 *a = AINT16(target);
          int16 *d = ((int16 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case INT32:
        { int32 *a = AINT32(target);
          int32 *d = ((int32 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case INT64:
        { int64 *a = AINT64(target);
          int64 *d = ((int64 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case FLOAT32:
        { float32 *a = AFLOAT32(target);
          float32 *d = ((float32 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
      case FLOAT64:
        { float64 *a = AFLOAT64(target);
          float64 *d = ((float64 *) source) + size;

          for (p = target->size; p-- > 0; )
            { if (in)
                a[p] = *--d; 
              else
                a[p] = 0;
              in = Dec_Slice(slice);
            }
          break;
        }
  }

  Kill_Slice(slice);
}
 
Array *Pad_Array_Inplace(Array *R(M(source)), Coordinate *F(anchor), Coordinate *F(shape))
{ Dimn_Type  *scrd, *acrd, *dims;
  Size_Type   size;
  int         i, ndims;

  ndims = anchor->size;
  if (anchor->size != shape->size || source->ndims != shape->size)
    { fprintf(stderr,"Coordinates and/or source array are not of same dimensionality");
      fprintf(stderr," (Pad_Array_Inplace)\n");
      exit (1);
    }
  if ( ! (source->ndims == ndims || source->ndims == ndims+1 && source->kind != PLAIN_KIND))
    { fprintf(stderr,"Source and coordinate dimensionality do not match (Pad_Array_Inplace)\n");
      exit (1);
    }

  size = source->size;
  scrd = ADIMN(shape);
  acrd = ADIMN(anchor);
  dims = source->dims;
  if (source->ndims != ndims)
    { source->size = kind_size[source->kind];
      if (source->kind == COMPLEX_KIND)
        dims += 1;
    }
  else
    source->size = 1;
  for (i = 0; i < ndims; i++)
    { int m = scrd[i];
      scrd[i] = acrd[i] + (dims[i]-1);
      dims[i] = m;
      source->size *= m;
    }

  allocate_array_data(source,array_dsize(source),"Expland_Array_In_Place");

  expand_array(source,source->data,size,anchor,shape);
  
  return (source);
}


Array *G(Pad_Array_Copy)(Array *source, Coordinate *F(anchor), Coordinate *F(shape))
{ Array      *target;
  Dimn_Type  *scrd, *acrd, *dims;
  int         i, ndims;
 
  ndims = anchor->size;
  if (ndims != shape->size)
    { fprintf(stderr,"Coordinates are not of same dimensionality (Pad_Array_Copy)\n");
      exit (1);
    }
  if ( ! (source->ndims == ndims || source->ndims == ndims+1 && source->kind != PLAIN_KIND))
    { fprintf(stderr,"Source and coordinate dimensionality do not match (Pad_Array_Copy)\n");
      exit (1);
    }

  scrd = ADIMN(shape);
  acrd = ADIMN(anchor);

  if (source->ndims == ndims)
    { target = Make_Array(PLAIN_KIND,source->type,source->ndims,scrd);
      target->kind = source->kind;
    }
  else
    target = Make_Array(source->kind,source->type,ndims,scrd);

  dims = source->dims;
  if (source->ndims != ndims && source->kind == COMPLEX_KIND)
    dims += 1;
  for (i = 0; i < ndims; i++)
    scrd[i] = acrd[i] + (dims[i]-1);

  expand_array(target,source->data,source->size,anchor,shape);

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  CORRELATION AND REGRESSION ROUTINES                                                 *
 *                                                                                      *
 ****************************************************************************************/

static double inner_product_arrays(Array_Or_Slice *o1, Array_Or_Slice *o2)
{ Indx_Type p, q;
  Size_Type n;
  Array    *a1 = (Array *) o1;
  Array    *a2 = (Array *) o2;
  Slice    *s1 = (Array *) o1;
  Slice    *s2 = (Array *) o2;
  double    s;
  int       alice1, alice2;

  if (alice1 = Is_Slice(o1))
    a1 = Slice_Array(s1);
  if (alice2 = Is_Slice(o2))
    a2 = Slice_Array(s2);

  n = Slice_Volume(o1);
  s = 0;
  switch (a1->type) {
      case UINT8:
        { uint8 *v1 = AUINT8(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case UINT16:
        { uint16 *v1 = AUINT16(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case UINT32:
        { uint32 *v1 = AUINT32(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case UINT64:
        { uint64 *v1 = AUINT64(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case INT8:
        { int8 *v1 = AINT8(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case INT16:
        { int16 *v1 = AINT16(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case INT32:
        { int32 *v1 = AINT32(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case INT64:
        { int64 *v1 = AINT64(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case FLOAT32:
        { float32 *v1 = AFLOAT32(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
      case FLOAT64:
        { float64 *v1 = AFLOAT64(a1);
          switch (a2->type) {
              case UINT8:
                { uint8 *v2 = AUINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT16:
                { uint16 *v2 = AUINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT32:
                { uint32 *v2 = AUINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case UINT64:
                { uint64 *v2 = AUINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT8:
                { int8 *v2 = AINT8(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT16:
                { int16 *v2 = AINT16(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT32:
                { int32 *v2 = AINT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case INT64:
                { int64 *v2 = AINT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT32:
                { float32 *v2 = AFLOAT32(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
              case FLOAT64:
                { float64 *v2 = AFLOAT64(a2);
                  if (alice1)
                    if (alice2)
                      { p = Set_Slice_To_First(s1);
                        q = Set_Slice_To_First(s2);
                        while (n-- > 0)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      { p = Set_Slice_To_First(s1);
                        for (q = 0; q < n; q++)
                          { s += v1[p]*v2[q];
                            p = Next_Slice_Index(s1);
                          }
                      }
                  else
                    if (alice2)
                      { q = Set_Slice_To_First(s2);
                        for (p = 0; p < n; p++)
                          { s += v1[p]*v2[q];
                            q = Next_Slice_Index(s2);
                          }
                      }
                    else
                      for (p = 0; p < n; p++)
                        s += v1[p]*v2[p];
                  return (s);
                }
          }
        }
  }
}

static double sum_array(Array_Or_Slice *o)
{ Indx_Type p;
  Size_Type n;
  Array    *a = (Array *) o;
  Slice    *s = (Array *) o;
  double    t;
  int       alice;

  if (alice = Is_Slice(o))
    a = Slice_Array(s);

  n = Slice_Volume(o);
  t = 0;
  switch (a->type) {
      case UINT8:
        { uint8 *v = AUINT8(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case UINT16:
        { uint16 *v = AUINT16(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case UINT32:
        { uint32 *v = AUINT32(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case UINT64:
        { uint64 *v = AUINT64(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case INT8:
        { int8 *v = AINT8(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case INT16:
        { int16 *v = AINT16(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case INT32:
        { int32 *v = AINT32(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case INT64:
        { int64 *v = AINT64(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case FLOAT32:
        { float32 *v = AFLOAT32(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
      case FLOAT64:
        { float64 *v = AFLOAT64(a);
          if (alice)
            { p = Set_Slice_To_First(s);
              while (n-- > 0)
                { t += v[p];
                  p = Next_Slice_Index(s);
                }
            }
          else
            for (p = 0; p < n; p++)
              t += v[p];
          return (t);
        }
  }
}

static Double_Matrix *correlate(int n, Array_Or_Slice *a1, va_list *ap, char *routine)
{ static Array_Or_Slice **Args    = NULL;
  static int              Max_Arg = 0;

  Double_Matrix *rez;

  if (n > Max_Arg)
    { Max_Arg = n+5;
      Args    = (Array_Or_Slice **) Guarded_Realloc(Args,sizeof(Array_Or_Slice *)*Max_Arg,routine);
    }

  { int i;

    if (n > 0)
      Args[0] = a1;
    else
      { fprintf(stderr,"List of arrays is empty (%s)\n",routine);
        exit (1);
      }
    for (i = 1; i < n; i++)
      { Args[i] = (Array_Or_Slice *) va_arg(*ap,Array_Or_Slice *);
        if (Slice_Volume(Args[i]) != Slice_Volume(Args[0]))
          { fprintf(stderr,"Arrays do not have the same number of elements (%s)\n",routine);
            exit (1);
          }
      }
  }

  rez = Make_Array_With_Shape(PLAIN_KIND,FLOAT64,Coord2(n,n));
  
  { double *a = AFLOAT64(rez);
    int     i, j;

    for (i = 0; i < n; i++)
      for (j = 0; j <= i; j++)
        a[j*n+i] = a[i*n+j] = inner_product_arrays(Args[i],Args[j]);
  }
  
  return (rez);
}

static Double_Vector *array_means(int n, Array_Or_Slice *a1, va_list *ap, char *routine)
{ Double_Vector *rez;

  rez = Make_Array_With_Shape(PLAIN_KIND,FLOAT64,Coord1(n));
  
  { double *a = AFLOAT64(rez);
    int     i;

    a[0] = sum_array(a1);
    for (i = 1; i < n; i++)
      a[i] = sum_array((Array_Or_Slice *) va_arg(*ap,Array_Or_Slice *));
  }
  
  return (rez);
}

Double_Matrix *Correlation(int n, Array_Or_Slice *a1, ...)
{ va_list        ap;
  Double_Matrix *rez;

  va_start(ap,a1);
  rez = correlate(n,a1,&ap,"Correlation");
  va_end(ap);
  return (rez);
}

Double_Matrix *Covariance(int n, Array_Or_Slice *a1, ...)
{ va_list        ap;
  Double_Matrix *rez;
  Double_Vector *sum;

  va_start(ap,a1);
  rez = correlate(n,a1,&ap,"Covariance");
  va_end(ap);

  va_start(ap,a1);
  sum = array_means(n,a1,&ap,"Covariance");
  va_end(ap);

  { double *a = AFLOAT64(rez);
    double *m = AFLOAT64(sum);
    double  mi, mj, s;
    int     i, j;

    for (i = 0; i < n; i++)
      { mi = m[i]/n;
        for (j = 0; j <= i; j++)
          { s  = a[j*n+i];
            mj = m[j];
            a[j*n+i] = a[i*n+j] = (s - mj*mi)/n;
          }
      }
  }
  
  return (rez);
}

Double_Matrix *Pearson_Correlation(int n, Array_Or_Slice *a1, ...)
{ va_list        ap;
  Double_Matrix *rez;
  Double_Vector *sum;

  va_start(ap,a1);
  rez = correlate(n,a1,&ap,"Pearson_Correlation");
  va_end(ap);

  va_start(ap,a1);
  sum = array_means(n,a1,&ap,"Pearson_Correlation");
  va_end(ap);

  { double *a = AFLOAT64(rez);
    double *m = AFLOAT64(sum);
    double  mi, mj, s;
    int     i, j;

    for (i = 0; i < n; i++)
      { mi = m[i]/n;
        for (j = 0; j <= i; j++)
          { s  = a[j*n+i];
            mj = m[j];
            a[j*n+i] = a[i*n+j] = (s - mj*mi)/n;
          }
      }

    for (i = n*n-1; i >= 0; i -= n+1)
      a[i] = sqrt(a[i]);

    for (i = 1; i < n; i++)
      { mi = a[i*n+i];
        for (j = 0; j < i; j++)
          a[j*n+i] = a[i*n+j] /= (mi * a[j*n+j]);
      }

    for (i = n*n-1; i >= 0; i -= n+1)
      a[i] = 1.;
  }
  
  return (rez);
}

Double_Vector *Linear_Regression(int n, Array_Or_Slice *obs, Array_Or_Slice *in1, ...)
{ va_list        ap;
  Double_Matrix *cof;
  Double_Vector *tgt;
  LU_Factor     *lu;
  int            stable;
  
  if (Slice_Volume(obs) != Slice_Volume(in1))
    { fprintf(stderr,"Arrays do not have the same number of elements (Linear_Regression)\n");
      exit (1);
    }

  va_start(ap,in1);
  cof = correlate(n,in1,&ap,"Linear_Regression");
  va_end(ap);

  tgt = Make_Array_With_Shape(PLAIN_KIND,FLOAT64,Coord1(n));
  
  { double *a = AFLOAT64(tgt);
    int     i;

    va_start(ap,in1);
    a[0] = inner_product_arrays(in1,obs);
    for (i = 1; i < n; i++)
      a[i] = inner_product_arrays((Array_Or_Slice *) va_arg(ap,Array_Or_Slice *),obs);
    va_end(ap);
  }

  lu = LU_Decompose(cof,&stable);
  if ( ! stable)
    fprintf(stderr,"Warning: Coefficient array inversion was unstable (Linear_Regression()\n");

  LU_Solve(tgt,lu);
  
  Free_LU_Factor(lu);

  return (tgt);
}
