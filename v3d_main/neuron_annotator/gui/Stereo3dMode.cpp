/*
 * Stereo3dMode.cpp
 *
 *  Created on: Nov 7, 2012
 *      Author: Christopher M. Bruns
 */

#include "Stereo3dMode.h"
#include "../../3drenderer/GLee_r.h"
#include <iostream>

using namespace std;

namespace jfrc {

// StereoEyeView sets either left or right eye view, depending on constructor argument.
StereoEyeView::StereoEyeView(Eye eyeActual, Eye eyeGeom)
    : mode(eyeActual == LEFT ? STEREO_LEFT_EYE : STEREO_RIGHT_EYE)
{
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    // Set camera for left eye
    // Rotate by about 4 degrees about Y axis
    // TODO - a shear operation on the projection matrix might clip better.
    // We'll solve that problem when it appears...
    // Need to PRE-multiply rotation matrix, so some tedious manipulation
    GLdouble viewMat[16];
    glGetDoublev(GL_MODELVIEW_MATRIX, viewMat); // remember current modelview
    glLoadIdentity();
    double angle = 1.7; // left eye
    if (eyeGeom == RIGHT) angle = -angle; // right eye is opposite direction
    glRotated(angle, 0, 1, 0); // put rotation in modelview
    glMultMatrixd(viewMat); // end result is premultiply by Rotation
    glDrawBuffer(GL_BACK); // for non-quad modes
}

/* virtual */ StereoEyeView::~StereoEyeView()
{
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
}


AnaglyphRedCyanEyeView::AnaglyphRedCyanEyeView(Eye eye, Eye eyeGeom)
        : StereoEyeView(eye, eyeGeom)
{
    mode = STEREO_ANAGLYPH_RED_CYAN;
    if (eye == LEFT)
        glColorMask(GL_TRUE, GL_FALSE, GL_FALSE, GL_TRUE); // red only
    else
        glColorMask(GL_FALSE, GL_TRUE, GL_TRUE, GL_TRUE); // cyan only
}

AnaglyphRedCyanEyeView::~AnaglyphRedCyanEyeView()
{
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE); // Show all colors
}


AnaglyphGreenMagentaEyeView::AnaglyphGreenMagentaEyeView(Eye eye, Eye eyeGeom)
        : StereoEyeView(eye, eyeGeom)
{
    mode = STEREO_ANAGLYPH_GREEN_MAGENTA;
    if (eye == LEFT)
        glColorMask(GL_FALSE, GL_TRUE, GL_FALSE, GL_TRUE); // green only
    else
        glColorMask(GL_TRUE, GL_FALSE, GL_TRUE, GL_TRUE); // magenta only
}

AnaglyphGreenMagentaEyeView::~AnaglyphGreenMagentaEyeView()
{
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE); // Show all colors
}


QuadBufferView::QuadBufferView(Eye eye, Eye eyeGeom)
    : StereoEyeView(eye, eyeGeom)
{
    mode = STEREO_QUAD_BUFFERED;
    if (eye == LEFT)
        glDrawBuffer(GL_BACK_LEFT);
    else
        glDrawBuffer(GL_BACK_RIGHT);
}

QuadBufferView::~QuadBufferView()
{
}


// Even numbered rows ON
static uint8_t rowStipple0Static[] = {
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00};

// Odd numbered rows ON
static uint8_t rowStipple1Static[] = {
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff};

// Even numbered columns ON
static uint8_t colStipple0Static[] = {
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA};

// Odd numbered columns ON
static uint8_t colStipple1Static[] = {
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55};

// Even/Even and Odd/Odd pixels ON
static GLubyte checkStipple0Static[] = {
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
    0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55};

// Even/Odd and Odd/Even pixels ON
static GLubyte checkStipple1Static[] = {
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
    0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA};

// Expose stipple patterns as class members
/* static */ const uint8_t* RowInterleavedStereoView::rowStipple0 = rowStipple0Static;
/* static */ const uint8_t* RowInterleavedStereoView::rowStipple1 = rowStipple1Static;
/* static */ const uint8_t* RowInterleavedStereoView::colStipple0 = colStipple0Static;
/* static */ const uint8_t* RowInterleavedStereoView::colStipple1 = colStipple1Static;
/* static */ const uint8_t* RowInterleavedStereoView::checkStipple0 = checkStipple0Static;
/* static */ const uint8_t* RowInterleavedStereoView::checkStipple1 = checkStipple1Static;


// Remember to call fillStencil() once before rendering
RowInterleavedStereoView::RowInterleavedStereoView(Eye eye, Eye eyeGeom, const uint8_t* stipple)
    : StereoEyeView(eye, eyeGeom)
    , stipple(stipple)
{
    mode = STEREO_ROW_INTERLEAVED;
    glPushAttrib(GL_ENABLE_BIT | GL_STENCIL_BUFFER_BIT);
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); // don't modify the stencil buffer
    glEnable(GL_STENCIL_TEST);

    // Left image in the zero regions
    if (eye == LEFT)
        glStencilFunc( GL_EQUAL, 0, ~0 );
    else
        glStencilFunc( GL_NOTEQUAL, 0, ~0 );
    GLenum err = glGetError();
    if (err != GL_NO_ERROR) {
        cerr << "OpenGL error " << err;
        cerr << " at " << __FILE__ << __LINE__;
        cerr << endl;
    }
}

RowInterleavedStereoView::~RowInterleavedStereoView()
{
    glPopAttrib();
}

// left and top refer to the absolute screen coordinates of the render window
// from, say, Qt method mapToGlobal(QPoint(0, 0))
void RowInterleavedStereoView::fillStencil(int left, int top, int width, int height)
{
    // int width = renderer.getScreenWidth();
    // int height = renderer.getScreenHeight();

    // Remember current OpenGL state
    glPushAttrib(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_ENABLE_BIT | GL_POLYGON_BIT | GL_STENCIL_BUFFER_BIT);
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();

    // Modify only the stencil buffer
    glDisable(GL_LIGHTING); // no shading
    glDisable(GL_DEPTH_TEST); // don't modify depth buffer
    glDisable(GL_BLEND);
    glDrawBuffer(GL_BACK);
    glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE); // don't modify color buffer
    glDepthMask(GL_FALSE);
    glEnable(GL_STENCIL_TEST);

    // Draw a rectangle over the full screen, into the stencil buffer
    // using the simplest possible OpenGL geometry
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glViewport(0, 0, width, height);
    glOrtho(0.0, width, 0.0, height, -1.0, 1.0); // 2D orthographic projection

    glClearStencil(0);
    glClear(GL_STENCIL_BUFFER_BIT);
    // glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE); // Modify the stencil buffer everywhere
    glStencilOp(GL_INVERT, GL_INVERT, GL_INVERT); // Modify the stencil buffer everywhere
    glStencilFunc(GL_ALWAYS, ~0, ~0);

    glColor4f(1,1,1,0); // All ones
    glLineWidth(1.0);
    glDisable(GL_LINE_SMOOTH);

    // It might not be possible to guarantee the registration of the stippling.  So use GL_LINES
    if ( (mode == jfrc::STEREO_ROW_INTERLEAVED)
        || (mode == jfrc::STEREO_CHECKER_INTERLEAVED) )
    {
        int offset = 0;
        // blank alternate rows
        offset = top % 2; // even=>0; odd=>1
        glBegin(GL_LINES);
        for(float y = 0.5 - offset + height; y >= 0; y -= 2) {
            glVertex3f(0, y, 0);
            glVertex3f(width, y, 0);
        }
        glEnd();
    }

    if ( (mode == jfrc::STEREO_COLUMN_INTERLEAVED)
        || (mode == jfrc::STEREO_CHECKER_INTERLEAVED) )
    {
        // blank alternate columns
        int offset = (left+1) % 2; 
        glBegin(GL_LINES);
        for(float x = 0.5 - offset; x <= width; x += 2) {
            glVertex3f(x, 0, 0);
            glVertex3f(x, height, 0);
        }
        glEnd();
    }

    // Restore OpenGL state
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
    glPopAttrib();
}

ColumnInterleavedStereoView::ColumnInterleavedStereoView(Eye eye, Eye eyeGeom, const uint8_t* stipple)
    : RowInterleavedStereoView(eye, eyeGeom, stipple)
{
    mode = STEREO_COLUMN_INTERLEAVED;
}

CheckerInterleavedStereoView::CheckerInterleavedStereoView(Eye eye, Eye eyeGeom, const uint8_t* stipple)
    : RowInterleavedStereoView(eye, eyeGeom, stipple)
{
    mode = STEREO_CHECKER_INTERLEAVED;
}

}

