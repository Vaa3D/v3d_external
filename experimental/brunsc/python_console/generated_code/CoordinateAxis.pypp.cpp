// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrappable_v3d.h"
#include "CoordinateAxis.pypp.hpp"

namespace bp = boost::python;

void register_CoordinateAxis_class(){

    { //::SimTK::CoordinateAxis
        typedef bp::class_< SimTK::CoordinateAxis > CoordinateAxis_exposer_t;
        CoordinateAxis_exposer_t CoordinateAxis_exposer = CoordinateAxis_exposer_t( "CoordinateAxis", "\n This class, along with its sister class CoordinateDirection, provides\nconvenient manipulation of the three coordinate axes via the definition of\nthree constants XAxis, YAxis, and ZAxis each with a unique subtype and implicit\nconversion to the integers 0, 1, and 2 whenever necessary.\\ Methods are\nprovided to allow code to be written once that can be used to work with the\naxes in any order.\n\nThere are also three CoordinateDirection constants NegXAxis, NegYAxis, and\nNegZAxis, also with unique types permitting efficient compile time\nmanipulation. These do not correspond to integers, however. Instead, they are\nobjects containing one of the CoordinateAxis objects combined with an integer\nthat is 1 or -1 to indicate the direction along that axis. The unary negation\noperator is overloaded so that -XAxis is NegXAxis and -NegZAxis is ZAxis.\nThere are implicit conversions to UnitVec3 for any CoordinateAxis or\nCoordinateDirection object, yielding the equivalent (normalized) unit vector\ncorresponding to any of the six directions, without doing any computation\n(and in particular, without normalizing).\naee CoordinateDirection **/\n", bp::no_init );
        bp::scope CoordinateAxis_scope( CoordinateAxis_exposer );
        bp::class_< SimTK::CoordinateAxis::XCoordinateAxis, bp::bases< SimTK::CoordinateAxis > >( "XCoordinateAxis", bp::init< >() );
        bp::class_< SimTK::CoordinateAxis::YCoordinateAxis, bp::bases< SimTK::CoordinateAxis > >( "YCoordinateAxis", bp::init< >() );
        bp::class_< SimTK::CoordinateAxis::ZCoordinateAxis, bp::bases< SimTK::CoordinateAxis > >( "ZCoordinateAxis", bp::init< >() );
        { //::SimTK::CoordinateAxis::areAllDifferentAxes
        
            typedef bool ( ::SimTK::CoordinateAxis::*areAllDifferentAxes_function_type )( ::SimTK::CoordinateAxis const &,::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "areAllDifferentAxes"
                , areAllDifferentAxes_function_type( &::SimTK::CoordinateAxis::areAllDifferentAxes )
                , ( bp::arg("axis2"), bp::arg("axis3") )
                , "\n Return true if neither C{axis2} nor C{axis3} is the same as this\n    axis nor each other; that is, (this,axis2,axis3) together cover all three\n    axes. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::areAllSameAxes
        
            typedef bool ( ::SimTK::CoordinateAxis::*areAllSameAxes_function_type )( ::SimTK::CoordinateAxis const &,::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "areAllSameAxes"
                , areAllSameAxes_function_type( &::SimTK::CoordinateAxis::areAllSameAxes )
                , ( bp::arg("axis2"), bp::arg("axis3") )
                , "\n Return true if both C{axis2} and C{axis3} are the same as this one. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::assertIndexIsInRange
        
            typedef void ( *assertIndexIsInRange_function_type )( int );
            
            CoordinateAxis_exposer.def( 
                "assertIndexIsInRange"
                , assertIndexIsInRange_function_type( &::SimTK::CoordinateAxis::assertIndexIsInRange )
                , ( bp::arg("i") )
                , "\n When in Debug mode, throw an assertion if the given integer is not\n    suited as a coordinate axis, as defined by isIndexInRange(). **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::crossProductAxis
        
            typedef ::SimTK::CoordinateAxis ( ::SimTK::CoordinateAxis::*crossProductAxis_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "crossProductAxis"
                , crossProductAxis_function_type( &::SimTK::CoordinateAxis::crossProductAxis )
                , ( bp::arg("axis2") )
                , "\n Return the coordinate axis along which the cross product of this axis\n    and C{axis2} would lie: same as this if C{axis2} is the same as this axis\n    (doesnt matter because the sign would be zero); otherwise, the third\n    axis that is neither this one nor C{axis2.} But note that the actual\n    result may be along that axis or in the negative direction along that\n    axis.  No floating point computations are performed.\n    aee crossProductSign(). **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::crossProductSign
        
            typedef int ( ::SimTK::CoordinateAxis::*crossProductSign_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "crossProductSign"
                , crossProductSign_function_type( &::SimTK::CoordinateAxis::crossProductSign )
                , ( bp::arg("axis2") )
                , "\n Return the sign that would result from a cross product between this\n    axis and C{axis2:} zero if C{axis2} is the same as this axis; one if the\n    result would be in the positive direction along the third axis; -1 if it\n    would be in the negative direction. No floating point computations are\n    performed. aee crossProductAxis() **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::dotProduct
        
            typedef int ( ::SimTK::CoordinateAxis::*dotProduct_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "dotProduct"
                , dotProduct_function_type( &::SimTK::CoordinateAxis::dotProduct )
                , ( bp::arg("axis2") )
                , "\n Perform a specialized dot product between this axis and C{axis2;}\n    returning one if they are the same axis and zero otherwise, without\n    performing any floating point operations. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::getCoordinateAxis
        
            typedef ::SimTK::CoordinateAxis const & ( *getCoordinateAxis_function_type )( int );
            
            CoordinateAxis_exposer.def( 
                "getCoordinateAxis"
                , getCoordinateAxis_function_type( &::SimTK::CoordinateAxis::getCoordinateAxis )
                , ( bp::arg("i") )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::SimTK::CoordinateAxis::getNextAxis
        
            typedef ::SimTK::CoordinateAxis ( ::SimTK::CoordinateAxis::*getNextAxis_function_type )(  ) const;
            
            CoordinateAxis_exposer.def( 
                "getNextAxis"
                , getNextAxis_function_type( &::SimTK::CoordinateAxis::getNextAxis )
                , "\n Return the next coordinate axis after this one:\n        - XAxis.getNextAxis()  returns YAxis\n        - YAxis.getNextAxis()  returns ZAxis\n        - ZAxis.getNextAxis()  returns XAxis **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::getPreviousAxis
        
            typedef ::SimTK::CoordinateAxis ( ::SimTK::CoordinateAxis::*getPreviousAxis_function_type )(  ) const;
            
            CoordinateAxis_exposer.def( 
                "getPreviousAxis"
                , getPreviousAxis_function_type( &::SimTK::CoordinateAxis::getPreviousAxis )
                , "\n Return the previous coordinate axis before this one:\n        - XAxis.getPreviousAxis()  returns ZAxis\n        - YAxis.getPreviousAxis()  returns XAxis\n        - ZAxis.getPreviousAxis()  returns YAxis **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::getThirdAxis
        
            typedef ::SimTK::CoordinateAxis ( ::SimTK::CoordinateAxis::*getThirdAxis_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "getThirdAxis"
                , getThirdAxis_function_type( &::SimTK::CoordinateAxis::getThirdAxis )
                , ( bp::arg("axis2") )
                , "\n Given this coordinate axis and one other, return the missing one:\n        - XAxis.getThirdAxis(YAxis) returns ZAxis (and vice versa)\n        - XAxis.getThirdAxis(ZAxis) returns YAxis (and vice versa)\n        - YAxis.getThirdAxis(ZAxis) returns XAxis (and vice versa)\n    @param[in] axis2    A coordinate axis that must be distinct from the\n        current one; it is a fatal error to provide the same axis.\n    Return: The unmentioned third axis. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isDifferentAxis
        
            typedef bool ( ::SimTK::CoordinateAxis::*isDifferentAxis_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "isDifferentAxis"
                , isDifferentAxis_function_type( &::SimTK::CoordinateAxis::isDifferentAxis )
                , ( bp::arg("axis2") )
                , "\n Return true if the given C{axis2} is not the same one as this\n    one.\\ You can use operator!=() to perform the same comparison.  **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isForwardCyclical
        
            typedef bool ( ::SimTK::CoordinateAxis::*isForwardCyclical_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "isForwardCyclical"
                , isForwardCyclical_function_type( &::SimTK::CoordinateAxis::isForwardCyclical )
                , ( bp::arg("axis2") )
                , "\n Return true if the given C{axis2} is the one following this one in a\n    forward cyclical direction, that is, if C{axis2} is the one that would be\n    reported by getNextAxis(). **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isIndexInRange
        
            typedef bool ( *isIndexInRange_function_type )( int );
            
            CoordinateAxis_exposer.def( 
                "isIndexInRange"
                , isIndexInRange_function_type( &::SimTK::CoordinateAxis::isIndexInRange )
                , ( bp::arg("i") )
                , "\n Return true if the given integer is suitable as a coordinate axis,\n    meaning it is one of 0, 1, or 2 designating XAxis, YAxis, or ZAxis,\n    respectively. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isNextAxis
        
            typedef bool ( ::SimTK::CoordinateAxis::*isNextAxis_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "isNextAxis"
                , isNextAxis_function_type( &::SimTK::CoordinateAxis::isNextAxis )
                , ( bp::arg("axis2") )
                , "\n Return true if the given C{axis2} is the one following this one as\n    would be reported by getNextAxis(). **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isPreviousAxis
        
            typedef bool ( ::SimTK::CoordinateAxis::*isPreviousAxis_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "isPreviousAxis"
                , isPreviousAxis_function_type( &::SimTK::CoordinateAxis::isPreviousAxis )
                , ( bp::arg("axis2") )
                , "\n Return true if the given C{axis2} is the one preceding this one as\n    would be reported by getPreviousAxis(). **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isReverseCyclical
        
            typedef bool ( ::SimTK::CoordinateAxis::*isReverseCyclical_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "isReverseCyclical"
                , isReverseCyclical_function_type( &::SimTK::CoordinateAxis::isReverseCyclical )
                , ( bp::arg("axis2") )
                , "\n Return true if the given C{axis2} is the one following this one in a\n    reverse cyclical direction, that is, if C{axis2} is the one that would be\n    reported by getPreviousAxis(). **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isSameAxis
        
            typedef bool ( ::SimTK::CoordinateAxis::*isSameAxis_function_type )( ::SimTK::CoordinateAxis const & ) const;
            
            CoordinateAxis_exposer.def( 
                "isSameAxis"
                , isSameAxis_function_type( &::SimTK::CoordinateAxis::isSameAxis )
                , ( bp::arg("axis2") )
                , "\n Return true if the given C{axis2} is the same as this one.\\ You\n    can use operator==() to perform the same comparison. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isXAxis
        
            typedef bool ( ::SimTK::CoordinateAxis::*isXAxis_function_type )(  ) const;
            
            CoordinateAxis_exposer.def( 
                "isXAxis"
                , isXAxis_function_type( &::SimTK::CoordinateAxis::isXAxis )
                , "\n Return true if this is the X axis. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isYAxis
        
            typedef bool ( ::SimTK::CoordinateAxis::*isYAxis_function_type )(  ) const;
            
            CoordinateAxis_exposer.def( 
                "isYAxis"
                , isYAxis_function_type( &::SimTK::CoordinateAxis::isYAxis )
                , "\n Return true if this is the Y axis. **/\n" );
        
        }
        { //::SimTK::CoordinateAxis::isZAxis
        
            typedef bool ( ::SimTK::CoordinateAxis::*isZAxis_function_type )(  ) const;
            
            CoordinateAxis_exposer.def( 
                "isZAxis"
                , isZAxis_function_type( &::SimTK::CoordinateAxis::isZAxis )
                , "\n Return true if this is the Z axis. **/\n" );
        
        }
        CoordinateAxis_exposer.def( "__int__", &SimTK::CoordinateAxis::operator int , "\n Implicit conversion of a CoordinateAxis to int 0, 1, or 2. **/\n" );
        CoordinateAxis_exposer.staticmethod( "assertIndexIsInRange" );
        CoordinateAxis_exposer.staticmethod( "getCoordinateAxis" );
        CoordinateAxis_exposer.staticmethod( "isIndexInRange" );
    }

}
